<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SRT 한글→일어 교체 (클릭삽입/빈줄제거/숫자줄분리/특수구간)</title>

  <style>
    :root { --gap: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h2 { margin: 0 0 8px; }
    .hint { color:#666; font-size: 13px; line-height:1.45; }

    .topbar{
      display:flex; gap:var(--gap); flex-wrap:wrap; align-items:flex-end;
      border:1px solid #e5e5e5; border-radius:12px; padding:12px; background:#fafafa;
    }
    .topbar .col{ min-width:280px; flex:1; }

    label{ display:block; font-weight:800; margin:8px 0 6px; }
    input[type="file"]{ width:100%; }

    .dropzone{
      border:2px dashed #999; border-radius:12px; padding:14px; background:#fff;
      cursor:pointer; user-select:none; transition:.15s;
    }
    .dropzone b{ font-weight:900; }
    .dropzone .small{ font-size:12px; color:#666; margin-top:6px; line-height:1.35; }
    .dropzone.dragover{ border-color:#111; background:#f1f1f1; }

    select{
      width:100%; padding:8px 10px; border-radius:10px; border:1px solid #ccc; background:#fff;
    }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      padding:10px 14px; border-radius:10px; border:1px solid #333;
      background:#111; color:#fff; cursor:pointer;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .status{ margin-top:8px; font-size:14px; }
    .status b{ font-weight:900; }

    .cfg{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .cfg input[type="number"]{ width:90px; padding:6px 8px; border-radius:10px; border:1px solid #ccc; }
    .cfg input[type="checkbox"]{ transform: translateY(1px); }

    .pill{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #ddd; font-size:12px; color:#444; background:#fff;
    }

    .grid{
      margin-top:var(--gap);
      display:grid; grid-template-columns:1.15fr 0.85fr; gap:var(--gap);
      height: calc(100vh - 255px);
      min-height: 520px;
    }
    .panel{
      border:1px solid #e5e5e5; border-radius:12px; overflow:hidden;
      display:flex; flex-direction:column; background:#fff;
    }
    .panelHeader{
      padding:10px 12px; border-bottom:1px solid #eee; background:#fcfcfc;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelHeader .title{ font-weight:900; }
    .panelHeader .small{ font-size:12px; color:#666; }
    .panelBody{ padding:12px; overflow:auto; flex:1; }

    textarea#outSrt{
      width:100%; min-height:180px; padding:10px; border-radius:10px; border:1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.45;
    }

    table{
      width:100%;
      border-collapse:collapse;
      margin-top:12px;
      table-layout: fixed;
    }
    th, td{ border:1px solid #eee; padding:8px; vertical-align:top; font-size:13px; }
    th{ background:#fafafa; position:sticky; top:0; z-index:2; }
    tr.unmatched{ background:#ffe5e5; }
    tr.clickable{ cursor:pointer; }
    tr.clickable:hover{ outline:2px solid #111; outline-offset:-2px; }
    tr.selectedRow{ outline:3px solid #111; outline-offset:-3px; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .ok{ color:#0a7; font-weight:900; }
    .bad{ color:#c00; font-weight:900; }

    /* === 요청: 테이블 폭 조정 === */
    th.colIdx, td.colIdx { width: 40px; }
    th.colTime, td.colTime { width: 110px; }
    td.colTime { font-size: 11.5px; } /* 1~2pt 작게 */
    th.colKo, td.colKo { width: 360px; }
    th.colJp, td.colJp { width: 360px; }
    th.colStat, td.colStat { width: 120px; }

    .jpEdit{
      width:100%;
      min-height:56px;
      resize:vertical;
      padding:8px;
      border-radius:10px;
      border:1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.35;
      background:#fff;
      box-sizing: border-box;
    }
    .jpEdit.fail{ border-color:#c00; background:#fff6f6; }

    /* DOCX view */
    .docxWrap{
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 1.55;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .docLine{
      display:block;
      padding: 2px 4px;
      border-radius: 6px;
      cursor: pointer;
    }
    .docLine:hover{ background:#f2f2f2; }
    .docLine.selected{ background:#ffe9a8; }
    .docBlank{ height: 10px; }

    .findBox{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .findBox input{ width:220px; padding:6px 10px; border-radius:10px; border:1px solid #ccc; }
    mark{ padding:0 2px; border-radius:4px; }

    .smallNote{ font-size:12px; color:#666; line-height:1.35; margin-top:8px; }
  </style>

  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
</head>

<body>
  <h2>SRT 한글 → 일본어 자동 교체 (DOCX 기반)</h2>
  <div class="hint">
    - 오른쪽 DOCX는 <b>줄 클릭</b>으로 왼쪽 치환칸에 삽입 (드래그 안 씀)<br/>
    - <b>일어–일어 사이 빈 줄 제거</b> + 삽입 시에도 <b>빈 줄 일괄 제거</b><br/>
    - <b>숫자+문장(예: 43 こうして…)</b>은 오른쪽에서 자동으로 <b>숫자/본문 줄 분리</b><br/>
    - “제목(한글)” 블록은 <b>タイトル / 本　　文</b> 값을 2줄로 출력
  </div>

  <div class="topbar">
    <div class="col">
      <div id="dropzone" class="dropzone" tabindex="0">
        <b>여기에 SRT 또는 DOCX 파일을 드래그&드롭</b><br/>
        <div class="small">또는 아래에서 파일 선택 / 최근 파일 선택</div>
      </div>

      <label>1) SRT 파일(한국어)</label>
      <input id="srtFile" type="file" accept=".srt,text/plain" />

      <label>최근 SRT</label>
      <select id="recentSrt" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col">
      <label>2) Word 번역 파일(.docx)</label>
      <input id="docxFile" type="file" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

      <label>최근 DOCX</label>
      <select id="recentDocx" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col" style="min-width: 440px;">
      <div class="cfg">
        <span class="pill">문장 병합 최대 블록</span>
        <input id="maxSentenceMerge" type="number" min="2" max="40" value="12" />

        <span class="pill">도입문 자동 병합</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="mergeIntro" type="checkbox" checked /> ON
        </label>

        <span class="pill">문장 끝(마침표) 우선</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="preferSentenceEnd" type="checkbox" checked /> ON
        </label>

        <span class="pill">[オープニングコメント] 제거</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="dropOpeningLabel" type="checkbox" checked /> ON
        </label>
      </div>

      <div class="controls">
        <button id="runBtn" disabled>변환 실행</button>
        <button id="dlBtn" disabled>결과 SRT 다운로드</button>
      </div>

      <div class="status" id="status">파일을 올려주세요.</div>
      <div class="smallNote">
        ※ 다운로드 파일명: <b>[SRT의 8자리날짜]_jp.srt</b> (예: 20260218_jp.srt)
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">결과(왼쪽)</div>
          <div class="small">상단: 최종 SRT / 하단: 매칭 상세(일본어 편집 가능)</div>
        </div>
        <div class="small" id="leftStat"></div>
      </div>

      <div class="panelBody">
        <label style="margin:0 0 6px;">최종 SRT 미리보기 (다운로드 기준)</label>
        <textarea id="outSrt" spellcheck="false" placeholder="변환 실행 후 결과가 표시됩니다."></textarea>

        <div class="smallNote">
          팁: 표의 일본어 편집칸을 클릭해 둔 뒤, 오른쪽 DOCX에서 <b>일본어 줄을 클릭</b>하면 자동 삽입됩니다.
          (기존 값 있으면 <b>아래줄로 추가</b>)
        </div>

        <div class="pill" style="margin-top:12px;">매칭 상세 (행 클릭 → 오른쪽 DOCX 하이라이트/이동)</div>

        <div style="max-height: 440px; overflow:auto; border:1px solid #eee; border-radius: 12px; margin-top:8px;">
          <table>
            <thead>
              <tr>
                <th class="colIdx">#</th>
                <th class="colTime">시간</th>
                <th class="colKo">원문(한글, 병합됨)</th>
                <th class="colJp">치환(일본어, 편집)</th>
                <th class="colStat">상태</th>
              </tr>
            </thead>
            <tbody id="detailBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">DOCX 원문(오른쪽)</div>
          <div class="small">일본어 줄 클릭 → 왼쪽 치환칸에 삽입</div>
        </div>

        <div class="findBox">
          <input id="docFind" type="text" placeholder="오른쪽 내용 검색(하이라이트)" />
          <button id="findBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">찾기</button>
          <button id="clearFindBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">해제</button>
        </div>
      </div>

      <div class="panelBody">
        <div id="docxView" class="docxWrap">(DOCX 파일을 올리면 여기에 내용이 표시됩니다)</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const recent = { srt: [], docx: [] };
  let srtText = "";
  let docxTextRaw = "";

  // ✅ 다운로드 파일명 생성용 (SRT에서 8자리 날짜 추출)
  let srtFileNameBase = "output";

  let lastBlocks = [];
  let lastReport = [];

  let docTitleExtract = { title: "", passage: "" };
  let docManuscriptMap = new Map();

  let docxViewLines = [];
  let lastFocusedTextarea = null;

  const statusEl = $("status");
  const runBtn = $("runBtn");
  const dlBtn = $("dlBtn");
  const outSrt = $("outSrt");
  const detailBody = $("detailBody");
  const leftStat = $("leftStat");

  const docxView = $("docxView");
  const docFind = $("docFind");
  const findBtn = $("findBtn");
  const clearFindBtn = $("clearFindBtn");

  const recentSrtSel = $("recentSrt");
  const recentDocxSel = $("recentDocx");
  const dropzone = $("dropzone");

  function setStatus(html) { statusEl.innerHTML = html; }
  function canRun() { return srtText.trim().length > 0 && docxTextRaw.trim().length > 0; }
  function updateRunBtn() { runBtn.disabled = !canRun(); }

  function upsertRecent(list, item) {
    const idx = list.findIndex(x => x.name === item.name);
    if (idx >= 0) list.splice(idx, 1);
    list.unshift(item);
    if (list.length > 8) list.length = 8;
  }
  function refreshRecentSelects() {
    recentSrtSel.innerHTML = `<option value="">(선택)</option>` +
      recent.srt.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentSrtSel.disabled = recent.srt.length === 0;

    recentDocxSel.innerHTML = `<option value="">(선택)</option>` +
      recent.docx.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentDocxSel.disabled = recent.docx.length === 0;
  }

  function hasHangul(str) { return /[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(str); }
  function hasJapanese(str) { return /[\u3040-\u30ff\u4e00-\u9fff]/.test(str); }

  function normalizeKo(str) {
    return (str || "")
      .replace(/\uFEFF/g, "")
      .replace(/[“”"]/g, "")
      .replace(/\s+/g, "")
      .replace(/[·…]/g, "")
      .trim();
  }

  function cleanKoKey(line) {
    const m = line.match(/^(.{1,30})\s*:\s*(.+)$/);
    if (m) {
      const left = m[1].trim();
      const right = m[2].trim();
      if (left.startsWith("[") && left.endsWith("]")) return right;
      if (left.length <= 8) return right;
    }
    return line.trim();
  }

  function normalizeTimeLine(t) { return (t || "").trim(); }

  function splitTimeRange(timeLine) {
    const parts = timeLine.split("-->").map(s => s.trim());
    return { start: parts[0] || "", end: parts[1] || "" };
  }

  function looksSentenceEnded(rawText) {
    const s = (rawText || "").trim();
    if (!s) return false;
    const tail = s.replace(/[”"'\s]+$/g, "");
    return /[\.。\!\?…]+$/.test(tail);
  }

  function isIntroVerseLine(koMergedRaw) {
    const s = (koMergedRaw || "").replace(/\s+/g, " ").trim();
    if (!s) return false;
    if (s.length > 40) return false;
    const hasChapVerse = /(\d+)\s*장.*?(\d+)\s*절/.test(s);
    if (!hasChapVerse) return false;
    const hasCue = /(을|를)\s*보(면|시?면)|을\s*보라|를\s*보라|을\s*살펴보면|를\s*살펴보면/.test(s);
    return hasCue || /을\s*보면,?$/.test(s) || /를\s*보면,?$/.test(s);
  }

  function isNumericOnlyBody(body) {
    const s = (body || "").trim();
    return /^\d+$/.test(s);
  }

  function isTitleMarker(body) {
    return (body || "").replace(/\s+/g, "").trim() === "제목";
  }

  function isOpeningMarker(body) {
    const s = (body || "").trim();
    return s.startsWith("[오프닝 멘트]") || s.startsWith("[오프닝멘트]") || s.startsWith("[오프닝") || s.startsWith("오프닝 멘트");
  }

  // ✅ SRT 파일명에서 8자리 숫자(YYYYMMDD) 우선 추출 -> 출력 파일명 베이스로
  function computeSrtBaseName(filename) {
    const name = (filename || "").replace(/^.*[\\/]/, "");
    const noExt = name.replace(/\.[^.]+$/, "");
    const m = noExt.match(/(\d{8})/);
    if (m && m[1]) return m[1];
    return noExt || "output";
  }

  function parseSrt(text) {
    const blocks = text.replace(/\r/g, "").split(/\n\s*\n/);
    const items = [];
    for (const blk of blocks) {
      const lines = blk.split("\n");
      if (lines.length < 2) continue;
      const time = normalizeTimeLine(lines[1] || "");
      const body = lines.slice(2).join("\n").trim();
      if (!time.includes("-->")) continue;
      items.push({ time, body });
    }
    return items;
  }

  function extractTitleAndPassage(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim()).filter(Boolean);
    let title = "";
    let passage = "";

    for (const ln of lines) {
      const s = ln.trim();
      if (!s) continue;

      if (!title) {
        const m = s.match(/^タイトル\s*:\s*(.+)$/);
        if (m && m[1]) title = m[1].trim();
      }
      if (!passage) {
        let m = s.match(/^本文\s*:\s*(.+)$/);
        if (!m || !m[1]) m = s.match(/^本[\s　]*文\s*:\s*(.+)$/);
        if (m && m[1]) passage = m[1].trim();
      }

      if (title && passage) break;
    }
    return { title, passage };
  }

  function extractManuscriptNumberedJP(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      if (!ln) continue;

      if (hasHangul(ln) && isOpeningMarker(ln)) break;

      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (!m) continue;

      const num = Number(m[1]);
      const rest = (m[2] || "").trim();
      if (!(Number.isFinite(num) && num > 0 && rest && hasJapanese(rest))) continue;

      let buf = [rest];
      for (let j = i + 1; j < lines.length; j++) {
        const nx = lines[j].trim();
        if (!nx) break;
        if (hasHangul(nx) && isOpeningMarker(nx)) break;
        const nxNum = nx.match(/^(\d{1,3})\s+(.+)$/);
        if (nxNum) break;
        buf.push(nx);
        i = j;
      }
      map.set(num, buf.join("\n").trim());
    }
    return map;
  }

  function stripJpLabels(jpLines, dropOpeningLabel) {
    const out = [];
    for (let ln of jpLines) {
      ln = (ln || "").trim();
      if (!ln) continue;
      if (dropOpeningLabel && /^\[オープニングコメント\]\s*:/i.test(ln)) continue;
      out.push(ln);
    }
    return out.join("\n").trim();
  }

  function buildKoToJpMap(docText, dropOpeningLabel) {
    const lines = docText.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    let currentKo = null;
    let jpBuf = [];

    function flush() {
      if (!currentKo) return;
      const koKey = normalizeKo(cleanKoKey(currentKo));
      const jpText = stripJpLabels(jpBuf, dropOpeningLabel);
      if (koKey && jpText) {
        if (!map.has(koKey)) map.set(koKey, jpText);
      }
      currentKo = null;
      jpBuf = [];
    }

    for (const ln of lines) {
      if (!ln) continue;
      if (hasHangul(ln)) { flush(); currentKo = ln; }
      else { if (currentKo) jpBuf.push(ln); }
    }
    flush();
    return map;
  }

  function removeBlankLinesAggressive(text) {
    const lines = (text || "").replace(/\r/g, "").split("\n");
    const out = [];
    for (const ln of lines) {
      const t = ln.trim();
      if (!t) continue;
      out.push(ln.trim());
    }
    return out.join("\n").trim();
  }

  function buildDocxViewLines(docRaw) {
    const rawLines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trimEnd());
    const step1 = [];

    for (const ln0 of rawLines) {
      const ln = (ln0 || "").trim();
      if (!ln) { step1.push(""); continue; }

      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (m) {
        const num = m[1];
        const rest = (m[2] || "").trim();
        if (rest && hasJapanese(rest)) {
          step1.push(num);
          step1.push(rest);
          continue;
        }
      }
      step1.push(ln);
    }

    const out = [];
    for (let i = 0; i < step1.length; i++) {
      const cur = (step1[i] ?? "").trim();
      const prev = (out.length ? out[out.length - 1] : "");
      const next = (i + 1 < step1.length) ? (step1[i + 1] ?? "").trim() : "";

      if (!cur) {
        if (prev && next && hasJapanese(prev) && hasJapanese(next)) continue;
        if (out.length && out[out.length - 1] === "") continue;
        out.push("");
        continue;
      }

      if (hasHangul(cur) && prev && prev !== "" && hasJapanese(prev)) {
        if (out[out.length - 1] !== "") out.push("");
      }

      out.push(cur);
    }

    while (out.length && out[out.length - 1] === "") out.pop();
    return out.map(t => ({ text: t, isBlank: t === "" }));
  }

  function renderDocxView(lines) {
    docxViewLines = lines;

    docxView.innerHTML = "";
    if (!lines || !lines.length) {
      docxView.textContent = "(DOCX 내용이 없습니다)";
      return;
    }

    lines.forEach((ln, idx) => {
      if (ln.isBlank) {
        const div = document.createElement("div");
        div.className = "docBlank";
        div.dataset.lineIndex = String(idx);
        docxView.appendChild(div);
        return;
      }
      const span = document.createElement("span");
      span.className = "docLine";
      span.dataset.lineIndex = String(idx);
      span.textContent = ln.text;
      docxView.appendChild(span);
      docxView.appendChild(document.createTextNode("\n"));
    });
  }

  function highlightInDocx(query) {
    const q = (query || "").trim();
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
    if (!q) return false;

    let first = null;
    all.forEach(el => {
      if (first) return;
      if ((el.textContent || "").includes(q)) first = el;
    });

    if (first) {
      first.classList.add("selected");
      first.scrollIntoView({ block: "center" });
      return true;
    }
    return false;
  }

  function makeDocxAnchorFromKo(koRaw) {
    const raw = (koRaw || "").trim();
    if (!raw) return "";

    const lines = raw.split("\n").map(s => s.trim()).filter(Boolean);
    const hangulLines = lines.filter(hasHangul).map(cleanKoKey);

    let bestLine = "";
    for (const ln of hangulLines) if (ln.length > bestLine.length) bestLine = ln;

    if (bestLine.length > 70) bestLine = bestLine.slice(0, 70);
    bestLine = bestLine.replace(/[“”"]/g, "").trim();
    return bestLine;
  }

  function rebuildOutSrtFromBlocks() {
    const lines = [];
    for (let i = 0; i < lastBlocks.length; i++) {
      const b = lastBlocks[i];
      const r = lastReport[i];
      const edited = (r && typeof r.jpEdited === "string") ? r.jpEdited.trim() : "";
      const body = edited ? edited : b.body;
      lines.push(`${b.idx}\n${b.time}\n${body}`);
    }
    const srtOut = lines.join("\n\n");
    outSrt.value = srtOut;
    return srtOut;
  }

  // ✅ OK/FAIL 카운트 갱신
  function refreshOkFailCounts() {
    let ok = 0, fail = 0;
    for (const r of lastReport) {
      if (r.ok) ok++; else fail++;
    }
    leftStat.textContent = `OK ${ok} / FAIL ${fail}`;
    setStatus(`변환 상태: <b>성공 ${ok}</b> / <b>실패 ${fail}</b> (치환칸 입력하면 자동 OK)`);
  }

  // ✅ 특정 행의 상태 UI를 OK/FAIL로 즉시 반영
  function updateRowUIByIndex(i) {
    const tr = detailBody.querySelector(`tr[data-report-index="${i}"]`);
    if (!tr) return;
    const r = lastReport[i];
    if (!r) return;

    if (r.ok) tr.classList.remove("unmatched");
    else tr.classList.add("unmatched");

    const statTd = tr.querySelector("td.colStat");
    if (!statTd) return;

    statTd.innerHTML = r.ok
      ? `<span class="ok">OK</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`
      : `<span class="bad">FAIL</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`;
  }

  function renderReport(report) {
    detailBody.innerHTML = "";
    lastReport = report;

    for (let i = 0; i < report.length; i++) {
      const r = report[i];
      const tr = document.createElement("tr");
      tr.classList.add("clickable");
      if (!r.ok) tr.classList.add("unmatched");
      tr.dataset.reportIndex = String(i);

      const jpInitial = r.jp || "";
      r.jpEdited = jpInitial;

      tr.innerHTML = `
        <td class="mono colIdx">${r.idx}</td>
        <td class="mono colTime">${r.time}</td>
        <td class="mono colKo">${r.ko || ""}</td>
        <td class="colJp">
          <textarea class="jpEdit ${r.ok ? "" : "fail"}"
            data-jp-index="${i}" spellcheck="false"
            placeholder="${r.ok ? "필요하면 일본어를 수정하세요" : "여기에 일본어를 직접 입력(FAIL 해결)"}">${jpInitial}</textarea>
        </td>
        <td class="colStat">
          ${r.ok
            ? `<span class="ok">OK</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`
            : `<span class="bad">FAIL</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`
          }
        </td>
      `;
      detailBody.appendChild(tr);
    }

    rebuildOutSrtFromBlocks();
    refreshOkFailCounts();
  }

  detailBody.addEventListener("focusin", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;
    lastFocusedTextarea = ta;
  });

  // ✅ 치환칸 입력 시: 내용 있으면 OK로 자동 변경 + 카운트 갱신
  detailBody.addEventListener("input", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;

    const idx = Number(ta.dataset.jpIndex);
    if (!Number.isFinite(idx) || !lastReport[idx]) return;

    lastReport[idx].jpEdited = ta.value;

    // ok/fail 판정: 입력칸에 실질 내용이 있으면 OK, 없으면 FAIL
    const hasText = (ta.value || "").trim().length > 0;
    lastReport[idx].ok = hasText;

    // textarea fail 스타일도 동기화
    if (hasText) ta.classList.remove("fail");
    else ta.classList.add("fail");

    updateRowUIByIndex(idx);
    rebuildOutSrtFromBlocks();
    refreshOkFailCounts();
  });

  detailBody.addEventListener("click", (e) => {
    const tr = e.target.closest("tr");
    if (!tr) return;
    const idx = Number(tr.dataset.reportIndex);
    const row = lastReport[idx];
    if (!row) return;

    const prev = detailBody.querySelector("tr.selectedRow");
    if (prev) prev.classList.remove("selectedRow");
    tr.classList.add("selectedRow");

    const anchor = makeDocxAnchorFromKo(row.ko);
    if (!anchor) return;
    docFind.value = anchor;
    highlightInDocx(anchor);
  });

  function insertToFocusedTextarea(text) {
    if (!lastFocusedTextarea) {
      setStatus(`<span style="color:#c00;font-weight:900;">주의:</span> 먼저 왼쪽 표에서 일본어 수정칸을 한 번 클릭해 주세요.`);
      return;
    }
    const cleaned = removeBlankLinesAggressive(text);
    if (!cleaned) return;

    const cur = lastFocusedTextarea.value || "";
    const nextVal = cur.trim() ? (cur.replace(/\s+$/,"") + "\n" + cleaned) : cleaned;

    lastFocusedTextarea.value = nextVal;

    const idx = Number(lastFocusedTextarea.dataset.jpIndex);
    if (Number.isFinite(idx) && lastReport[idx]) {
      lastReport[idx].jpEdited = nextVal;

      // ✅ 삽입 후 OK로 전환
      const hasText = nextVal.trim().length > 0;
      lastReport[idx].ok = hasText;

      if (hasText) lastFocusedTextarea.classList.remove("fail");
      else lastFocusedTextarea.classList.add("fail");

      updateRowUIByIndex(idx);
      refreshOkFailCounts();
    }

    lastFocusedTextarea.focus();
    lastFocusedTextarea.selectionStart = lastFocusedTextarea.selectionEnd = lastFocusedTextarea.value.length;

    rebuildOutSrtFromBlocks();
  }

  docxView.addEventListener("click", (e) => {
    const lineEl = e.target.closest(".docLine");
    if (!lineEl) return;
    const text = (lineEl.textContent || "").trim();
    if (!text) return;
    insertToFocusedTextarea(text);
  });

  function convertAll(srtItems, ko2jp, opts) {
    const out = [];
    const report = [];

    const MAX = Math.max(2, Math.min(40, Number(opts.maxSentenceMerge) || 12));
    const preferSentenceEnd = !!opts.preferSentenceEnd;
    const mergeIntro = !!opts.mergeIntro;

    let i = 0;
    let newIndex = 1;
    let srtOpeningSeen = false;

    while (i < srtItems.length) {
      const curBody = (srtItems[i].body || "").trim();
      if (isOpeningMarker(curBody)) srtOpeningSeen = true;

      if (isTitleMarker(curBody)) {
        const first = srtItems[i];
        const t = splitTimeRange(first.time);
        const newTime = `${t.start} --> ${t.end}`;

        const title = (docTitleExtract.title || "").trim();
        const passage = (docTitleExtract.passage || "").trim();
        const jp = [title, passage].filter(Boolean).join("\n").trim();

        const idx = String(newIndex++);
        out.push({ idx, time: newTime, body: jp || curBody });
        report.push({
          idx, time: newTime,
          ko: curBody,
          jp: jp || "",
          ok: !!jp,
          mergedFrom: 1,
          special: "TITLE"
        });

        i += 1;
        continue;
      }

      if (!srtOpeningSeen && isNumericOnlyBody(curBody)) {
        const num = Number(curBody);
        const jp = docManuscriptMap.get(num) || "";

        const first = srtItems[i];
        const t = splitTimeRange(first.time);
        const newTime = `${t.start} --> ${t.end}`;

        const idx = String(newIndex++);
        out.push({ idx, time: newTime, body: jp || curBody });
        report.push({
          idx, time: newTime,
          ko: curBody,
          jp: jp || "",
          ok: !!jp,
          mergedFrom: 1,
          special: "NUM"
        });

        i += 1;
        continue;
      }

      let mergedNorm = "";
      let mergedRaw = "";
      const candidates = [];
      let firstSentenceEndLen = -1;

      for (let k = 0; k < MAX && (i + k) < srtItems.length; k++) {
        const partRaw = srtItems[i + k].body || "";
        const partNorm = normalizeKo(partRaw);

        mergedNorm += partNorm;
        mergedRaw += (k === 0 ? "" : "\n") + partRaw;

        const isEnd = looksSentenceEnded(partRaw);
        if (isEnd && firstSentenceEndLen === -1) firstSentenceEndLen = k + 1;

        candidates.push({
          mergeLen: k + 1,
          norm: mergedNorm,
          raw: mergedRaw,
          isSentenceEnd: isEnd
        });
      }

      const ordered = preferSentenceEnd
        ? [...candidates].sort((a,b) => {
            if (a.isSentenceEnd !== b.isSentenceEnd) return a.isSentenceEnd ? -1 : 1;
            return a.mergeLen - b.mergeLen;
          })
        : candidates;

      let bestMatch = null;
      for (const c of ordered) {
        if (c.norm && ko2jp.has(c.norm)) { bestMatch = { ...c, jp: ko2jp.get(c.norm) }; break; }
      }

      let outLen = bestMatch ? bestMatch.mergeLen : (firstSentenceEndLen !== -1 ? firstSentenceEndLen : 1);

      if (mergeIntro) {
        let rawKoNow = "";
        for (let k = 0; k < outLen; k++) rawKoNow += (k===0?"":"\n") + (srtItems[i+k].body||"");
        rawKoNow = rawKoNow.trim();

        if (isIntroVerseLine(rawKoNow) && (i + outLen) < srtItems.length) {
          const j = i + outLen;
          let nextLen = 1;
          for (let k = 0; k < MAX && (j + k) < srtItems.length; k++) {
            if (looksSentenceEnded(srtItems[j + k].body || "")) { nextLen = k + 1; break; }
            nextLen = k + 1;
          }

          let norm2 = normalizeKo(rawKoNow);
          let rawKo2 = rawKoNow;

          for (let k = 0; k < nextLen; k++) {
            rawKo2 += "\n" + (srtItems[j + k].body || "");
            norm2 += normalizeKo(srtItems[j + k].body || "");
          }
          rawKo2 = rawKo2.trim();

          if (ko2jp.has(norm2)) {
            bestMatch = { mergeLen: outLen + nextLen, jp: ko2jp.get(norm2), norm: norm2, raw: rawKo2 };
            outLen = outLen + nextLen;
          } else {
            outLen = outLen + nextLen;
          }
        }
      }

      let rawKo = "";
      for (let k = 0; k < outLen; k++) rawKo += (k===0?"":"\n") + (srtItems[i+k].body||"");
      rawKo = rawKo.trim();

      const first = srtItems[i];
      const last = srtItems[i + outLen - 1];
      const t1 = splitTimeRange(first.time);
      const t2 = splitTimeRange(last.time);
      const newTime = `${t1.start} --> ${t2.end}`;

      const idx = String(newIndex++);
      if (bestMatch && bestMatch.mergeLen === outLen) {
        out.push({ idx, time: newTime, body: bestMatch.jp });
        report.push({ idx, time: newTime, ko: rawKo, jp: bestMatch.jp, ok: true, mergedFrom: outLen });
      } else {
        out.push({ idx, time: newTime, body: rawKo });
        report.push({ idx, time: newTime, ko: rawKo, jp: "", ok: false, mergedFrom: outLen });
      }

      i += outLen;
    }

    return { out, report };
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  async function loadSrtFromFile(file) {
    const text = await file.text();
    srtText = text;
    srtFileNameBase = computeSrtBaseName(file.name);

    upsertRecent(recent.srt, { name: file.name, text });
    refreshRecentSelects();

    setStatus(`SRT 로드됨: <b>${file.name}</b> → 저장명: <b>${srtFileNameBase}_jp.srt</b>`);
    updateRunBtn();
  }

  async function loadDocxFromFile(file) {
    const arrBuf = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer: arrBuf });
    docxTextRaw = (result.value || "").trim();

    upsertRecent(recent.docx, { name: file.name, text: docxTextRaw });
    refreshRecentSelects();

    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `DOCX 로드됨: <b>${file.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  }

  $("srtFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadSrtFromFile(f);
  });

  $("docxFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadDocxFromFile(f);
  });

  recentSrtSel.addEventListener("change", () => {
    const v = recentSrtSel.value;
    if (v === "") return;
    const item = recent.srt[Number(v)];
    if (!item) return;

    srtText = item.text;
    srtFileNameBase = computeSrtBaseName(item.name);

    setStatus(`최근 SRT 선택: <b>${item.name}</b> → 저장명: <b>${srtFileNameBase}_jp.srt</b>`);
    updateRunBtn();
  });

  recentDocxSel.addEventListener("change", () => {
    const v = recentDocxSel.value;
    if (v === "") return;
    const item = recent.docx[Number(v)];
    if (!item) return;

    docxTextRaw = item.text;

    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `최근 DOCX 선택: <b>${item.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  });

  function handleDropFiles(fileList) {
    const files = Array.from(fileList || []);
    if (!files.length) return;
    for (const f of files) {
      const name = (f.name || "").toLowerCase();
      if (name.endsWith(".srt")) loadSrtFromFile(f);
      else if (name.endsWith(".docx")) loadDocxFromFile(f);
    }
  }

  dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("dragover"); });
  dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
  dropzone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
    handleDropFiles(e.dataTransfer.files);
  });

  dropzone.addEventListener("click", () => {
    const picker = document.createElement("input");
    picker.type = "file";
    picker.multiple = true;
    picker.accept = ".srt,.docx";
    picker.onchange = () => handleDropFiles(picker.files);
    picker.click();
  });

  $("findBtn").addEventListener("click", () => highlightInDocx(docFind.value));
  $("clearFindBtn").addEventListener("click", () => {
    docFind.value = "";
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
  });

  runBtn.addEventListener("click", () => {
    try {
      const srtItems = parseSrt(srtText);
      const dropOpeningLabel = $("dropOpeningLabel").checked;
      const ko2jp = buildKoToJpMap(docxTextRaw, dropOpeningLabel);

      const opts = {
        maxSentenceMerge: $("maxSentenceMerge").value,
        preferSentenceEnd: $("preferSentenceEnd").checked,
        mergeIntro: $("mergeIntro").checked,
      };

      setStatus(`처리 중... (SRT <b>${srtItems.length}</b> / KO→JP 사전 <b>${ko2jp.size}</b> / 원고숫자 <b>${docManuscriptMap.size}</b>)`);

      const { out, report } = convertAll(srtItems, ko2jp, opts);

      lastBlocks = out;
      renderReport(report);
      dlBtn.disabled = false;

    } catch (err) {
      console.error(err);
      setStatus(`<span style="color:#c00;font-weight:900;">오류:</span> ${(err?.message || String(err))}`);
    }
  });

  dlBtn.addEventListener("click", () => {
    const content = rebuildOutSrtFromBlocks();
    if (!content.trim()) return;

    // ✅ 저장명 = SRT 숫자(YYYYMMDD)_jp.srt
    downloadText(`${srtFileNameBase}_jp.srt`, content);
  });

})();
</script>
</body>
</html>
