<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SRT 한글→일어 교체 (클릭삽입/빈줄제거/숫자줄분리/특수구간)</title>

  <style>
    :root { --gap: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h2 { margin: 0 0 8px; }
    .hint { color:#666; font-size: 13px; line-height:1.45; }

    .topbar{
      display:flex; gap:var(--gap); flex-wrap:wrap; align-items:flex-end;
      border:1px solid #e5e5e5; border-radius:12px; padding:12px; background:#fafafa;
    }
    .topbar .col{ min-width:280px; flex:1; }

    label{ display:block; font-weight:800; margin:8px 0 6px; }
    input[type="file"]{ width:100%; }

    .dropzone{
      border:2px dashed #999; border-radius:12px; padding:14px; background:#fff;
      cursor:pointer; user-select:none; transition:.15s;
    }
    .dropzone b{ font-weight:900; }
    .dropzone .small{ font-size:12px; color:#666; margin-top:6px; line-height:1.35; }
    .dropzone.dragover{ border-color:#111; background:#f1f1f1; }

    select{
      width:100%; padding:8px 10px; border-radius:10px; border:1px solid #ccc; background:#fff;
    }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      padding:10px 14px; border-radius:10px; border:1px solid #333;
      background:#111; color:#fff; cursor:pointer;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .status{ margin-top:8px; font-size:14px; }
    .status b{ font-weight:900; }

    .cfg{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .cfg input[type="number"]{ width:90px; padding:6px 8px; border-radius:10px; border:1px solid #ccc; }
    .cfg input[type="checkbox"]{ transform: translateY(1px); }

    .pill{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #ddd; font-size:12px; color:#444; background:#fff;
    }

    .grid{
      margin-top:var(--gap);
      display:grid; grid-template-columns:1.15fr 0.85fr; gap:var(--gap);
      height: calc(100vh - 335px);
      min-height: 520px;
    }
    .panel{
      border:1px solid #e5e5e5; border-radius:12px; overflow:hidden;
      display:flex; flex-direction:column; background:#fff;
    }
    .panelHeader{
      padding:10px 12px; border-bottom:1px solid #eee; background:#fcfcfc;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelHeader .title{ font-weight:900; }
    .panelHeader .small{ font-size:12px; color:#666; }
    .panelBody{ padding:12px; overflow:auto; flex:1; }

    textarea#outSrt{
      width:100%; min-height:180px; padding:10px; border-radius:10px; border:1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.45;
    }

    table{ width:100%; border-collapse:collapse; margin-top:12px; }
    th, td{ border:1px solid #eee; padding:8px; vertical-align:top; font-size:13px; }
    th{ background:#fafafa; position:sticky; top:0; z-index:2; }
    tr.unmatched{ background:#ffe5e5; }
    tr.clickable{ cursor:pointer; }
    tr.clickable:hover{ outline:2px solid #111; outline-offset:-2px; }
    tr.selectedRow{ outline:3px solid #111; outline-offset:-3px; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .ok{ color:#0a7; font-weight:900; }
    .bad{ color:#c00; font-weight:900; }

    .jpEdit{
      width:100%;
      min-height:56px;
      resize:vertical;
      padding:8px;
      border-radius:10px;
      border:1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.35;
      background:#fff;
    }
    .jpEdit.fail{ border-color:#c00; background:#fff6f6; }

    /* DOCX view */
    .docxWrap{
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 1.55;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .docLine{
      display:block;
      padding: 2px 4px;
      border-radius: 6px;
      cursor: pointer;
    }
    .docLine:hover{ background:#f2f2f2; }
    .docLine.selected{ background:#ffe9a8; }
    .docBlank{ height: 10px; }

    .findBox{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .findBox input{ width:220px; padding:6px 10px; border-radius:10px; border:1px solid #ccc; }
    mark{ padding:0 2px; border-radius:4px; }

    .smallNote{ font-size:12px; color:#666; line-height:1.35; margin-top:8px; }
  </style>

  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
</head>

<body>
  <h2>SRT 한글 → 일본어 자동 교체 (DOCX 기반)</h2>
  <div class="hint">
    - 오른쪽 DOCX는 <b>줄 클릭</b>으로 왼쪽 치환칸에 삽입 (드래그 안 씀)<br/>
    - <b>일어–일어 사이 빈 줄 제거</b> + 삽입 시에도 <b>빈 줄 일괄 제거</b><br/>
    - <b>숫자+문장(예: 43 こうして…)</b>은 오른쪽에서 자동으로 <b>숫자/본문 줄 분리</b><br/>
    - “제목(한글)” 블록은 <b>タイトル / 本　　文</b> 값을 2줄로 출력
  </div>

  <div class="topbar">
    <div class="col">
      <div id="dropzone" class="dropzone" tabindex="0">
        <b>여기에 SRT 또는 DOCX 파일을 드래그&드롭</b><br/>
        <div class="small">또는 아래에서 파일 선택 / 최근 파일 선택</div>
      </div>

      <label>1) SRT 파일(한국어)</label>
      <input id="srtFile" type="file" accept=".srt,text/plain" />

      <label>최근 SRT</label>
      <select id="recentSrt" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col">
      <label>2) Word 번역 파일(.docx)</label>
      <input id="docxFile" type="file" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

      <label>최근 DOCX</label>
      <select id="recentDocx" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col" style="min-width: 440px;">
      <div class="cfg">
        <span class="pill">문장 병합 최대 블록</span>
        <input id="maxSentenceMerge" type="number" min="2" max="40" value="12" />

        <span class="pill">도입문 자동 병합</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="mergeIntro" type="checkbox" checked /> ON
        </label>

        <span class="pill">문장 끝(마침표) 우선</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="preferSentenceEnd" type="checkbox" checked /> ON
        </label>

        <span class="pill">[オープニングコメント] 제거</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="dropOpeningLabel" type="checkbox" checked /> ON
        </label>
      </div>

      <div class="controls">
        <button id="runBtn" disabled>변환 실행</button>
        <button id="dlBtn" disabled>결과 SRT 다운로드</button>
      </div>

      <div class="status" id="status">파일을 올려주세요.</div>
      <div class="smallNote">
        ※ 다운로드 파일명: <b>{YYYYMMDD}_jp.srt</b> (자동)
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">결과(왼쪽)</div>
          <div class="small">상단: 최종 SRT / 하단: 매칭 상세(일본어 편집 가능)</div>
        </div>
        <div class="small" id="leftStat"></div>
      </div>

      <div class="panelBody">
        <label style="margin:0 0 6px;">최종 SRT 미리보기 (다운로드 기준)</label>
        <textarea id="outSrt" spellcheck="false" placeholder="변환 실행 후 결과가 표시됩니다."></textarea>

        <div class="smallNote">
          팁: 표의 일본어 편집칸을 클릭해 둔 뒤, 오른쪽 DOCX에서 <b>일본어 줄을 클릭</b>하면 자동 삽입됩니다.
          (기존 값 있으면 <b>아래줄로 추가</b>)
        </div>

        <div class="pill" style="margin-top:12px;">매칭 상세 (행 클릭 → 오른쪽 DOCX 하이라이트/이동)</div>

        <div style="max-height: 440px; overflow:auto; border:1px solid #eee; border-radius: 12px; margin-top:8px;">
          <table>
            <thead>
              <tr>
                <th style="width:64px;">#</th>
                <th style="width:220px;">시간</th>
                <th>원문(한글, 병합됨)</th>
                <th style="width:360px;">치환(일본어, 편집)</th>
                <th style="width:140px;">상태</th>
              </tr>
            </thead>
            <tbody id="detailBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">DOCX 원문(오른쪽)</div>
          <div class="small">일본어 줄 클릭 → 왼쪽 치환칸에 삽입</div>
        </div>

        <div class="findBox">
          <input id="docFind" type="text" placeholder="오른쪽 내용 검색(하이라이트)" />
          <button id="findBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">찾기</button>
          <button id="clearFindBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">해제</button>
        </div>
      </div>

      <div class="panelBody">
        <div id="docxView" class="docxWrap">(DOCX 파일을 올리면 여기에 내용이 표시됩니다)</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const recent = { srt: [], docx: [] };
  let srtText = "";
  let docxTextRaw = "";

  let lastBlocks = [];   // output blocks
  let lastReport = [];   // rows

  // “제목” 추출용
  let docTitleExtract = { title: "", passage: "" };

  // “원고 숫자” 추출용 (DOCX에서 오프닝 전까지만)
  let docManuscriptMap = new Map(); // number -> jp text (multi-line allowed)

  // 오른쪽 표시용 라인(렌더링 전)
  let docxViewLines = []; // { text, isBlank }

  // 마지막으로 포커스된 일본어 편집칸 DOM
  let lastFocusedTextarea = null;

  const statusEl = $("status");
  const runBtn = $("runBtn");
  const dlBtn = $("dlBtn");
  const outSrt = $("outSrt");
  const detailBody = $("detailBody");
  const leftStat = $("leftStat");

  const docxView = $("docxView");
  const docFind = $("docFind");
  const findBtn = $("findBtn");
  const clearFindBtn = $("clearFindBtn");

  const recentSrtSel = $("recentSrt");
  const recentDocxSel = $("recentDocx");
  const dropzone = $("dropzone");

  function setStatus(html) { statusEl.innerHTML = html; }
  function canRun() { return srtText.trim().length > 0 && docxTextRaw.trim().length > 0; }
  function updateRunBtn() { runBtn.disabled = !canRun(); }

  function upsertRecent(list, item) {
    const idx = list.findIndex(x => x.name === item.name);
    if (idx >= 0) list.splice(idx, 1);
    list.unshift(item);
    if (list.length > 8) list.length = 8;
  }
  function refreshRecentSelects() {
    recentSrtSel.innerHTML = `<option value="">(선택)</option>` +
      recent.srt.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentSrtSel.disabled = recent.srt.length === 0;

    recentDocxSel.innerHTML = `<option value="">(선택)</option>` +
      recent.docx.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentDocxSel.disabled = recent.docx.length === 0;
  }

  // ===== helpers =====
  function hasHangul(str) { return /[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(str); }
  function hasJapanese(str) { return /[\u3040-\u30ff\u4e00-\u9fff]/.test(str); }

  function normalizeKo(str) {
    return (str || "")
      .replace(/\uFEFF/g, "")
      .replace(/[“”"]/g, "")
      .replace(/\s+/g, "")
      .replace(/[·…]/g, "")
      .trim();
  }

  function cleanKoKey(line) {
    const m = line.match(/^(.{1,30})\s*:\s*(.+)$/);
    if (m) {
      const left = m[1].trim();
      const right = m[2].trim();
      if (left.startsWith("[") && left.endsWith("]")) return right;
      if (left.length <= 8) return right;
    }
    return line.trim();
  }

  function normalizeTimeLine(t) { return (t || "").trim(); }

  function splitTimeRange(timeLine) {
    const parts = timeLine.split("-->").map(s => s.trim());
    return { start: parts[0] || "", end: parts[1] || "" };
  }

  function looksSentenceEnded(rawText) {
    const s = (rawText || "").trim();
    if (!s) return false;
    const tail = s.replace(/[”"'\s]+$/g, "");
    return /[\.。\!\?…]+$/.test(tail);
  }

  function isIntroVerseLine(koMergedRaw) {
    const s = (koMergedRaw || "").replace(/\s+/g, " ").trim();
    if (!s) return false;
    if (s.length > 40) return false;
    const hasChapVerse = /(\d+)\s*장.*?(\d+)\s*절/.test(s);
    if (!hasChapVerse) return false;
    const hasCue = /(을|를)\s*보(면|시?면)|을\s*보라|를\s*보라|을\s*살펴보면|를\s*살펴보면/.test(s);
    return hasCue || /을\s*보면,?$/.test(s) || /를\s*보면,?$/.test(s);
  }

  function isNumericOnlyBody(body) {
    const s = (body || "").trim();
    return /^\d+$/.test(s);
  }

  function isTitleMarker(body) {
    return (body || "").replace(/\s+/g, "").trim() === "제목";
  }

  function isOpeningMarker(body) {
    const s = (body || "").trim();
    return s.startsWith("[오프닝 멘트]") || s.startsWith("[오프닝멘트]") || s.startsWith("[오프닝") || s.startsWith("오프닝 멘트");
  }

  // ===== SRT parse =====
  function parseSrt(text) {
    const blocks = text.replace(/\r/g, "").split(/\n\s*\n/);
    const items = [];
    for (const blk of blocks) {
      const lines = blk.split("\n");
      if (lines.length < 2) continue;
      const time = normalizeTimeLine(lines[1] || "");
      const body = lines.slice(2).join("\n").trim();
      if (!time.includes("-->")) continue;
      items.push({ time, body });
    }
    return items;
  }

  // ===== DOCX: title/passage extraction (タイトル / 本　　文) =====
  function extractTitleAndPassage(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim()).filter(Boolean);
    let title = "";
    let passage = "";

    for (const ln of lines) {
      const s = ln.trim();
      if (!s) continue;

      if (!title) {
        const m = s.match(/^タイトル\s*:\s*(.+)$/);
        if (m && m[1]) title = m[1].trim();
      }

      if (!passage) {
        // "本文:" 기본
        let m = s.match(/^本文\s*:\s*(.+)$/);
        if (!m || !m[1]) {
          // "本　　文:" 등 공백/전각공백 허용
          m = s.match(/^本[\s　]*文\s*:\s*(.+)$/);
        }
        if (m && m[1]) passage = m[1].trim();
      }

      if (title && passage) break;
    }

    return { title, passage };
  }

  // ===== DOCX: extract manuscript numbered JP lines BEFORE opening marker in DOCX =====
  function extractManuscriptNumberedJP(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      if (!ln) continue;

      if (hasHangul(ln) && isOpeningMarker(ln)) break;

      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (!m) continue;

      const num = Number(m[1]);
      const rest = (m[2] || "").trim();
      if (!(Number.isFinite(num) && num > 0 && rest && hasJapanese(rest))) continue;

      let buf = [rest];
      for (let j = i + 1; j < lines.length; j++) {
        const nx = lines[j].trim();
        if (!nx) break;
        if (hasHangul(nx) && isOpeningMarker(nx)) break;
        const nxNum = nx.match(/^(\d{1,3})\s+(.+)$/);
        if (nxNum) break;
        buf.push(nx);
        i = j;
      }
      map.set(num, buf.join("\n").trim());
    }
    return map;
  }

  // ===== KO->JP dict build =====
  function stripJpLabels(jpLines, dropOpeningLabel) {
    const out = [];
    for (let ln of jpLines) {
      ln = (ln || "").trim();
      if (!ln) continue;
      if (dropOpeningLabel && /^\[オープニングコメント\]\s*:/i.test(ln)) continue;
      out.push(ln);
    }
    return out.join("\n").trim();
  }

  function buildKoToJpMap(docText, dropOpeningLabel) {
    const lines = docText.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    let currentKo = null;
    let jpBuf = [];

    function flush() {
      if (!currentKo) return;
      const koKey = normalizeKo(cleanKoKey(currentKo));
      const jpText = stripJpLabels(jpBuf, dropOpeningLabel);
      if (koKey && jpText) {
        if (!map.has(koKey)) map.set(koKey, jpText);
      }
      currentKo = null;
      jpBuf = [];
    }

    for (const ln of lines) {
      if (!ln) continue;
      if (hasHangul(ln)) { flush(); currentKo = ln; }
      else { if (currentKo) jpBuf.push(ln); }
    }
    flush();
    return map;
  }

  // ===== TEXT CLEAN: remove blank lines between JP lines & for insertion =====
  function removeBlankLinesAggressive(text) {
    // "일어-일어 사이 빈줄" 제거 목적: 공백줄(빈줄/스페이스줄) 전부 제거
    const lines = (text || "").replace(/\r/g, "").split("\n");
    const out = [];
    for (const ln of lines) {
      const t = ln.trim();
      if (!t) continue; // 빈줄 제거
      out.push(ln.trim());
    }
    return out.join("\n").trim();
  }

  // ===== DOCX VIEW PREPROCESS =====
  // 1) "43 こうして..." -> "43" + "こうして..." 분리
  // 2) 일어-일어 사이 빈줄 제거
  // 3) 한글로 넘어가기 직전엔 빈줄 1줄(구분)
  function buildDocxViewLines(docRaw) {
    const rawLines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trimEnd());
    const step1 = [];

    for (const ln0 of rawLines) {
      const ln = (ln0 || "").trim();
      if (!ln) { step1.push(""); continue; }

      // 숫자+일어 라인 분리
      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (m) {
        const num = m[1];
        const rest = (m[2] || "").trim();
        if (rest && hasJapanese(rest)) {
          step1.push(num);
          step1.push(rest);
          continue;
        }
      }
      step1.push(ln);
    }

    // step2: 일어-일어 사이 빈줄 제거 + ko 전 빈줄 1줄 보장
    const out = [];
    for (let i = 0; i < step1.length; i++) {
      const cur = (step1[i] ?? "").trim();
      const prev = (out.length ? out[out.length - 1] : "");
      const next = (i + 1 < step1.length) ? (step1[i + 1] ?? "").trim() : "";

      if (!cur) {
        // 빈줄 후보:
        // - prev와 next가 둘 다 일본어면 제거 (일어-일어 빈줄 금지)
        if (prev && next && hasJapanese(prev) && hasJapanese(next)) {
          continue;
        }
        // - 그 외는 일단 한 줄만 허용(연속 빈줄 제거)
        if (out.length && out[out.length - 1] === "") continue;
        out.push("");
        continue;
      }

      // JP -> KO로 넘어갈 때는 KO 앞에 빈줄 1줄 보장
      if (hasHangul(cur) && prev && prev !== "" && hasJapanese(prev)) {
        if (out[out.length - 1] !== "") out.push("");
      }

      // KO -> JP는 빈줄 금지 (바로 다음줄)
      // (이미 빈줄이 있으면 제거되는 방향)
      out.push(cur);
    }

    // 끝 빈줄 제거
    while (out.length && out[out.length - 1] === "") out.pop();

    // 렌더링용 구조
    return out.map(t => ({ text: t, isBlank: t === "" }));
  }

  // ===== DOCX VIEW RENDER =====
  function renderDocxView(lines) {
    docxViewLines = lines;

    docxView.innerHTML = "";
    if (!lines || !lines.length) {
      docxView.textContent = "(DOCX 내용이 없습니다)";
      return;
    }

    lines.forEach((ln, idx) => {
      if (ln.isBlank) {
        const div = document.createElement("div");
        div.className = "docBlank";
        div.dataset.lineIndex = String(idx);
        docxView.appendChild(div);
        return;
      }
      const span = document.createElement("span");
      span.className = "docLine";
      span.dataset.lineIndex = String(idx);
      span.textContent = ln.text;
      docxView.appendChild(span);
      docxView.appendChild(document.createTextNode("\n"));
    });
  }

  // ===== DOCX FIND (simple highlight by rebuilding with mark) =====
  function escapeHtml(s) {
    return (s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;");
  }

  function highlightInDocx(query) {
    // 라인 기반 렌더링이므로, 단순히 "선택 표시" + 스크롤만 처리
    const q = (query || "").trim();
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
    if (!q) return false;

    // 첫 매칭 라인 찾기
    let first = null;
    all.forEach(el => {
      if (first) return;
      if ((el.textContent || "").includes(q)) first = el;
    });

    if (first) {
      first.classList.add("selected");
      first.scrollIntoView({ block: "center" });
      return true;
    }
    return false;
  }

  function makeDocxAnchorFromKo(koRaw) {
    const raw = (koRaw || "").trim();
    if (!raw) return "";

    const lines = raw.split("\n").map(s => s.trim()).filter(Boolean);
    const hangulLines = lines.filter(hasHangul).map(cleanKoKey);

    let bestLine = "";
    for (const ln of hangulLines) if (ln.length > bestLine.length) bestLine = ln;

    if (bestLine.length > 70) bestLine = bestLine.slice(0, 70);
    bestLine = bestLine.replace(/[“”"]/g, "").trim();
    return bestLine;
  }

  // ===== output rebuild =====
  function rebuildOutSrtFromBlocks() {
    const lines = [];
    for (let i = 0; i < lastBlocks.length; i++) {
      const b = lastBlocks[i];
      const r = lastReport[i];
      const edited = (r && typeof r.jpEdited === "string") ? r.jpEdited.trim() : "";
      const body = edited ? edited : b.body;
      lines.push(`${b.idx}\n${b.time}\n${body}`);
    }
    const srtOut = lines.join("\n\n");
    outSrt.value = srtOut;
    return srtOut;
  }

  // ===== render table =====
  function renderReport(report) {
    detailBody.innerHTML = "";
    lastReport = report;

    let okCount = 0, badCount = 0;

    for (let i = 0; i < report.length; i++) {
      const r = report[i];
      const tr = document.createElement("tr");
      tr.classList.add("clickable");
      if (!r.ok) tr.classList.add("unmatched");
      tr.dataset.reportIndex = String(i);

      const jpInitial = r.jp || "";
      r.jpEdited = jpInitial;

      tr.innerHTML = `
        <td class="mono">${r.idx}</td>
        <td class="mono">${r.time}</td>
        <td class="mono">${r.ko || ""}</td>
        <td>
          <textarea class="jpEdit ${r.ok ? "" : "fail"}"
            data-jp-index="${i}" spellcheck="false"
            placeholder="${r.ok ? "필요하면 일본어를 수정하세요" : "여기에 일본어를 직접 입력(FAIL 해결)"}">${jpInitial}</textarea>
        </td>
        <td>
          ${r.ok
            ? `<span class="ok">OK</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`
            : `<span class="bad">FAIL</span><div class="mono" style="font-size:12px;color:#666;">merge:${r.mergedFrom}${r.special ? " / " + r.special : ""}</div>`
          }
        </td>
      `;
      detailBody.appendChild(tr);

      if (r.ok) okCount++; else badCount++;
    }

    leftStat.textContent = `OK ${okCount} / FAIL ${badCount}`;
    setStatus(`변환 완료: <b>성공 ${okCount}</b> / <b>실패 ${badCount}</b> (오른쪽 클릭 삽입으로 빠르게 채우기)`);

    rebuildOutSrtFromBlocks();
  }

  // textarea focus tracking
  detailBody.addEventListener("focusin", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;
    lastFocusedTextarea = ta;
  });

  // textarea edit -> rebuild
  detailBody.addEventListener("input", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;
    const idx = Number(ta.dataset.jpIndex);
    if (!Number.isFinite(idx) || !lastReport[idx]) return;

    // 입력 중에도 빈줄 싫으면 여기서도 정리(원하면 ON/OFF로 뺄 수 있음)
    lastReport[idx].jpEdited = ta.value;
    rebuildOutSrtFromBlocks();
  });

  // row click -> docx highlight
  detailBody.addEventListener("click", (e) => {
    const tr = e.target.closest("tr");
    if (!tr) return;
    const idx = Number(tr.dataset.reportIndex);
    const row = lastReport[idx];
    if (!row) return;

    const prev = detailBody.querySelector("tr.selectedRow");
    if (prev) prev.classList.remove("selectedRow");
    tr.classList.add("selectedRow");

    const anchor = makeDocxAnchorFromKo(row.ko);
    if (!anchor) return;
    docFind.value = anchor;

    // 라인 기반 검색
    highlightInDocx(anchor);
  });

  // ===== RIGHT CLICK INSERT (doc line click -> textarea append) =====
  function insertToFocusedTextarea(text) {
    if (!lastFocusedTextarea) {
      setStatus(`<span style="color:#c00;font-weight:900;">주의:</span> 먼저 왼쪽 표에서 일본어 수정칸을 한 번 클릭해 주세요.`);
      return;
    }
    const cleaned = removeBlankLinesAggressive(text);
    if (!cleaned) return;

    const cur = lastFocusedTextarea.value || "";
    const nextVal = cur.trim() ? (cur.replace(/\s+$/,"") + "\n" + cleaned) : cleaned;

    lastFocusedTextarea.value = nextVal;

    const idx = Number(lastFocusedTextarea.dataset.jpIndex);
    if (Number.isFinite(idx) && lastReport[idx]) lastReport[idx].jpEdited = nextVal;

    lastFocusedTextarea.focus();
    lastFocusedTextarea.selectionStart = lastFocusedTextarea.selectionEnd = lastFocusedTextarea.value.length;

    rebuildOutSrtFromBlocks();
  }

  docxView.addEventListener("click", (e) => {
    const lineEl = e.target.closest(".docLine");
    if (!lineEl) return;
    const text = (lineEl.textContent || "").trim();
    if (!text) return;

    // 클릭한 라인이 숫자만이면: 다음 라인이 존재하고 일본어면 “숫자+다음라인”을 함께 넣고 싶어할 수도 있으나,
    // 사용자가 원한 건 "붙어있는 걸 분리해서 보기"였고, 삽입은 주로 문장 삽입이므로:
    // - 숫자만이면 그냥 숫자만 삽입(원하면 아래 주석 해제해 '숫자+다음라인' 삽입으로 변경 가능)
    //
    // const idx = Number(lineEl.dataset.lineIndex);
    // if (/^\d+$/.test(text) && docxViewLines[idx+1] && docxViewLines[idx+1].text) {
    //   insertToFocusedTextarea(text + "\n" + docxViewLines[idx+1].text);
    //   return;
    // }

    insertToFocusedTextarea(text);
  });

  // ===== Convert (special + sentence merge + intro merge) =====
  function convertAll(srtItems, ko2jp, opts) {
    const out = [];
    const report = [];

    const MAX = Math.max(2, Math.min(40, Number(opts.maxSentenceMerge) || 12));
    const preferSentenceEnd = !!opts.preferSentenceEnd;
    const mergeIntro = !!opts.mergeIntro;

    let i = 0;
    let newIndex = 1;

    // SRT에서 [오프닝 멘트] 이후 숫자 원고치환 금지
    let srtOpeningSeen = false;

    while (i < srtItems.length) {
      const curBody = (srtItems[i].body || "").trim();
      if (isOpeningMarker(curBody)) srtOpeningSeen = true;

      // (1) 제목 특수 처리: body == "제목"
      if (isTitleMarker(curBody)) {
        const first = srtItems[i];
        const t = splitTimeRange(first.time);
        const newTime = `${t.start} --> ${t.end}`;

        const title = (docTitleExtract.title || "").trim();
        const passage = (docTitleExtract.passage || "").trim();
        const jp = [title, passage].filter(Boolean).join("\n").trim();

        const idx = String(newIndex++);
        out.push({ idx, time: newTime, body: jp || curBody });
        report.push({
          idx, time: newTime,
          ko: curBody,
          jp: jp || "",
          ok: !!jp,
          mergedFrom: 1,
          special: "TITLE"
        });

        i += 1;
        continue;
      }

      // (2) 숫자만 블록 특수 처리 (오프닝 이전만)
      if (!srtOpeningSeen && isNumericOnlyBody(curBody)) {
        const num = Number(curBody);
        const jp = docManuscriptMap.get(num) || "";

        const first = srtItems[i];
        const t = splitTimeRange(first.time);
        const newTime = `${t.start} --> ${t.end}`;

        const idx = String(newIndex++);
        out.push({ idx, time: newTime, body: jp || curBody });
        report.push({
          idx, time: newTime,
          ko: curBody,
          jp: jp || "",
          ok: !!jp,
          mergedFrom: 1,
          special: "NUM"
        });

        i += 1;
        continue;
      }

      // (3) 일반 처리: 문장 병합 + 도입문 병합
      let mergedNorm = "";
      let mergedRaw = "";
      const candidates = [];
      let firstSentenceEndLen = -1;

      for (let k = 0; k < MAX && (i + k) < srtItems.length; k++) {
        const partRaw = srtItems[i + k].body || "";
        const partNorm = normalizeKo(partRaw);

        mergedNorm += partNorm;
        mergedRaw += (k === 0 ? "" : "\n") + partRaw;

        const isEnd = looksSentenceEnded(partRaw);
        if (isEnd && firstSentenceEndLen === -1) firstSentenceEndLen = k + 1;

        candidates.push({
          mergeLen: k + 1,
          norm: mergedNorm,
          raw: mergedRaw,
          isSentenceEnd: isEnd
        });
      }

      const ordered = preferSentenceEnd
        ? [...candidates].sort((a,b) => {
            if (a.isSentenceEnd !== b.isSentenceEnd) return a.isSentenceEnd ? -1 : 1;
            return a.mergeLen - b.mergeLen;
          })
        : candidates;

      let bestMatch = null;
      for (const c of ordered) {
        if (c.norm && ko2jp.has(c.norm)) { bestMatch = { ...c, jp: ko2jp.get(c.norm) }; break; }
      }

      let outLen = bestMatch ? bestMatch.mergeLen : (firstSentenceEndLen !== -1 ? firstSentenceEndLen : 1);

      // 도입문(민수기 몇장 몇절...) -> 다음 문장 덩어리까지 붙이기
      if (mergeIntro) {
        let rawKoNow = "";
        for (let k = 0; k < outLen; k++) rawKoNow += (k===0?"":"\n") + (srtItems[i+k].body||"");
        rawKoNow = rawKoNow.trim();

        if (isIntroVerseLine(rawKoNow) && (i + outLen) < srtItems.length) {
          const j = i + outLen;
          let nextLen = 1;
          for (let k = 0; k < MAX && (j + k) < srtItems.length; k++) {
            if (looksSentenceEnded(srtItems[j + k].body || "")) { nextLen = k + 1; break; }
            nextLen = k + 1;
          }

          let norm2 = normalizeKo(rawKoNow);
          let rawKo2 = rawKoNow;

          for (let k = 0; k < nextLen; k++) {
            rawKo2 += "\n" + (srtItems[j + k].body || "");
            norm2 += normalizeKo(srtItems[j + k].body || "");
          }
          rawKo2 = rawKo2.trim();

          if (ko2jp.has(norm2)) {
            bestMatch = { mergeLen: outLen + nextLen, jp: ko2jp.get(norm2), norm: norm2, raw: rawKo2 };
            outLen = outLen + nextLen;
          } else {
            outLen = outLen + nextLen;
          }
        }
      }

      let rawKo = "";
      for (let k = 0; k < outLen; k++) rawKo += (k===0?"":"\n") + (srtItems[i+k].body||"");
      rawKo = rawKo.trim();

      const first = srtItems[i];
      const last = srtItems[i + outLen - 1];
      const t1 = splitTimeRange(first.time);
      const t2 = splitTimeRange(last.time);
      const newTime = `${t1.start} --> ${t2.end}`;

      const idx = String(newIndex++);
      if (bestMatch && bestMatch.mergeLen === outLen) {
        out.push({ idx, time: newTime, body: bestMatch.jp });
        report.push({ idx, time: newTime, ko: rawKo, jp: bestMatch.jp, ok: true, mergedFrom: outLen });
      } else {
        out.push({ idx, time: newTime, body: rawKo });
        report.push({ idx, time: newTime, ko: rawKo, jp: "", ok: false, mergedFrom: outLen });
      }

      i += outLen;
    }

    return { out, report };
  }

  // ===== download =====
  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  // ===== load files =====
  async function loadSrtFromFile(file) {
    const text = await file.text();
    srtText = text;
    upsertRecent(recent.srt, { name: file.name, text });
    refreshRecentSelects();
    setStatus(`SRT 로드됨: <b>${file.name}</b>`);
    updateRunBtn();
  }

  async function loadDocxFromFile(file) {
    const arrBuf = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer: arrBuf });
    docxTextRaw = (result.value || "").trim();

    upsertRecent(recent.docx, { name: file.name, text: docxTextRaw });
    refreshRecentSelects();

    // extract title/passage & manuscript map
    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    // build view lines & render
    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `DOCX 로드됨: <b>${file.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  }

  // ===== inputs =====
  $("srtFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadSrtFromFile(f);
  });

  $("docxFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadDocxFromFile(f);
  });

  recentSrtSel.addEventListener("change", () => {
    const v = recentSrtSel.value;
    if (v === "") return;
    const item = recent.srt[Number(v)];
    if (!item) return;
    srtText = item.text;
    setStatus(`최근 SRT 선택: <b>${item.name}</b>`);
    updateRunBtn();
  });

  recentDocxSel.addEventListener("change", () => {
    const v = recentDocxSel.value;
    if (v === "") return;
    const item = recent.docx[Number(v)];
    if (!item) return;

    docxTextRaw = item.text;

    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `최근 DOCX 선택: <b>${item.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  });

  // ===== dropzone =====
  function handleDropFiles(fileList) {
    const files = Array.from(fileList || []);
    if (!files.length) return;
    for (const f of files) {
      const name = (f.name || "").toLowerCase();
      if (name.endsWith(".srt")) loadSrtFromFile(f);
      else if (name.endsWith(".docx")) loadDocxFromFile(f);
    }
  }

  dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("dragover"); });
  dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
  dropzone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
    handleDropFiles(e.dataTransfer.files);
  });

  dropzone.addEventListener("click", () => {
    const picker = document.createElement("input");
    picker.type = "file";
    picker.multiple = true;
    picker.accept = ".srt,.docx";
    picker.onchange = () => handleDropFiles(picker.files);
    picker.click();
  });

  // ===== right search =====
  $("findBtn").addEventListener("click", () => highlightInDocx(docFind.value));
  $("clearFindBtn").addEventListener("click", () => {
    docFind.value = "";
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
  });

  // ===== run =====
  runBtn.addEventListener("click", () => {
    try {
      const srtItems = parseSrt(srtText);
      const dropOpeningLabel = $("dropOpeningLabel").checked;
      const ko2jp = buildKoToJpMap(docxTextRaw, dropOpeningLabel);

      const opts = {
        maxSentenceMerge: $("maxSentenceMerge").value,
        preferSentenceEnd: $("preferSentenceEnd").checked,
        mergeIntro: $("mergeIntro").checked,
      };

      setStatus(`처리 중... (SRT <b>${srtItems.length}</b> / KO→JP 사전 <b>${ko2jp.size}</b> / 원고숫자 <b>${docManuscriptMap.size}</b>)`);

      const { out, report } = convertAll(srtItems, ko2jp, opts);

      lastBlocks = out;
      renderReport(report);
      dlBtn.disabled = false;

    } catch (err) {
      console.error(err);
      setStatus(`<span style="color:#c00;font-weight:900;">오류:</span> ${(err?.message || String(err))}`);
    }
  });

  dlBtn.addEventListener("click", () => {
    // 다운로드 직전: 표 편집값 기준으로 srt 재생성
    const content = rebuildOutSrtFromBlocks();
    if (!content.trim()) return;

    // YYYYMMDD stamp
    const stamp = new Date().toISOString().slice(0,10).replaceAll("-","");
    downloadText(`${stamp}_jp.srt`, content);
  });

})();
</script>
</body>
</html>
