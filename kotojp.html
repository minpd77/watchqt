<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SRT 한글→일본어 교체 (SRT 타이밍 고정)</title>

  <style>
    :root { --gap: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h2 { margin: 0 0 8px; display:flex; align-items:center; gap:10px; }
    .hint { color:#666; font-size: 13px; line-height:1.45; }

    /* help icon */
    .helpBtn{
      width:28px; height:28px; border-radius:999px;
      border:1px solid #333; background:#fff; color:#111;
      display:inline-flex; align-items:center; justify-content:center;
      font-weight:900; cursor:pointer; user-select:none;
    }
    .helpBtn:hover{ background:#f2f2f2; }

    /* modal */
    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.45);
      display:none;
      align-items:center; justify-content:center;
      z-index:9999;
      padding: 18px;
    }
    .modal{
      width:min(780px, 96vw);
      background:#fff;
      border-radius:14px;
      border:1px solid #e5e5e5;
      box-shadow: 0 16px 40px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .modalHeader{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid #eee;
      background:#fcfcfc;
      font-weight:900;
    }
    .modalClose{
      border:1px solid #333; background:#fff; color:#111;
      border-radius:10px; padding:6px 10px; cursor:pointer;
      font-weight:800;
    }
    .modalBody{ padding:14px 16px; }
    .modalBody ul{ margin:0; padding-left: 18px; }
    .modalBody li{ margin: 8px 0; line-height:1.5; }

    .topbar{
      display:flex; gap:var(--gap); flex-wrap:wrap; align-items:flex-end;
      border:1px solid #e5e5e5; border-radius:12px; padding:12px; background:#fafafa;
    }
    .topbar .col{ min-width:280px; flex:1; }

    label{ display:block; font-weight:800; margin:8px 0 6px; }
    input[type="file"]{ width:100%; }

    .dropzone{
      border:2px dashed #999; border-radius:12px; padding:14px; background:#fff;
      cursor:pointer; user-select:none; transition:.15s;
    }
    .dropzone b{ font-weight:900; }
    .dropzone .small{ font-size:12px; color:#666; margin-top:6px; line-height:1.35; }
    .dropzone.dragover{ border-color:#111; background:#f1f1f1; }

    select{
      width:100%; padding:8px 10px; border-radius:10px; border:1px solid #ccc; background:#fff;
    }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      padding:10px 14px; border-radius:10px; border:1px solid #333;
      background:#111; color:#fff; cursor:pointer;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .status{ margin-top:8px; font-size:14px; }
    .status b{ font-weight:900; }

    .cfg{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .cfg input[type="checkbox"]{ transform: translateY(1px); }

    .pill{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #ddd; font-size:12px; color:#444; background:#fff;
    }

    .grid{
      margin-top:var(--gap);
      display:grid; grid-template-columns:1.15fr 0.85fr; gap:var(--gap);
      height: calc(100vh - 255px);
      min-height: 800px;
    }
    .panel{
      border:1px solid #e5e5e5; border-radius:12px; overflow:hidden;
      display:flex; flex-direction:column; background:#fff;
    }
    .panelHeader{
      padding:10px 12px; border-bottom:1px solid #eee; background:#fcfcfc;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelHeader .title{ font-weight:900; }
    .panelHeader .small{ font-size:12px; color:#666; }
    .panelBody{ padding:12px; overflow:auto; flex:1; }

    table{
      width:100%;
      border-collapse:collapse;
      margin-top:12px;
      table-layout: fixed;
    }
    th, td{ border:1px solid #eee; padding:8px; vertical-align:top; font-size:13px; }
    th{ background:#fafafa; position:sticky; top:0; z-index:2; }
    tr.unmatched{ background:#ffe5e5; }
    tr.clickable{ cursor:pointer; }
    tr.clickable:hover{ outline:2px solid #111; outline-offset:-2px; }
    tr.selectedRow{ outline:3px solid #111; outline-offset:-3px; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .ok{ color:#0a7; font-weight:900; }
    .bad{ color:#c00; font-weight:900; }

    /* table width tuning (요청 반영) */
th.colIdx, td.colIdx { width: 15px; }           /* # 칸: 50% */
th.colTime, td.colTime { width: 60px; }         /* 시간 칸: 70% (110px -> 77px) */
td.colTime { font-size: 8px; }                  /* 시간 숫자 텍스트: 70% (11.5px -> 약 8px) */

th.colKo, td.colKo { width: 300px; }            /* 원문(한글): 85% (360px -> 306px) */
th.colJp, td.colJp { width: 360px; }            /* 치환(일본어) 유지 */
th.colStat, td.colStat { width: 100px; }        /* 상태 유지 */


    .jpEdit{
      width:100%;
      min-height:56px;
      resize:vertical;
      padding:8px;
      border-radius:10px;
      border:1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:1.35;
      background:#fff;
      box-sizing: border-box;
    }
    .jpEdit.fail{ border-color:#c00; background:#fff6f6; }

    /* DOCX view */
    .docxWrap{
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 1.55;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .docLine{
      display:block;
      padding: 2px 4px;
      border-radius: 6px;
      cursor: pointer;
    }
    .docLine:hover{ background:#f2f2f2; }
    .docLine.selected{ background:#ffe9a8; }
    .docBlank{ height: 10px; }

    .findBox{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .findBox input{ width:220px; padding:6px 10px; border-radius:10px; border:1px solid #ccc; }

    .smallNote{ font-size:12px; color:#666; line-height:1.35; margin-top:8px; }
  </style>

  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
</head>

<body>
  <h2>
    SRT 한글 → 일본어 자동 교체 (SRT 타이밍 고정)
    <span id="helpBtn" class="helpBtn" title="도움말">?</span>
  </h2>

  <!-- Help Modal -->
  <div id="helpModal" class="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="modalHeader">
        <div id="helpTitle">도움말</div>
        <button id="helpClose" class="modalClose">닫기</button>
      </div>
      <div class="modalBody">
        <ul>
          <li>✅ <b>SRT가 나눈 블록(시간/번호) 그대로 유지</b>하고, 각 블록 한글에 해당하는 DOCX 일본어를 넣습니다.</li>
          <li>오른쪽 DOCX는 <b>줄 클릭</b>으로 왼쪽 치환칸에 삽입(드래그 안 씀).</li>
          <li><b>일어–일어 사이 빈 줄 제거</b> + 삽입 시에도 <b>빈 줄 일괄 제거</b></li>
          <li><b>숫자+문장(예: 43 こうして…)</b>은 오른쪽에서 자동으로 <b>숫자/본문 줄 분리</b></li>
          <li>“<b>제목(한글)</b>” 블록은 <b>タイトル / 本　　文</b> 값을 2줄로 출력</li>
          <li><b>숫자만 블록(1,2,3...)</b>은 <b>[오프닝 멘트] 이전까지만</b> DOCX 원고(1 〜)로 대체</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="topbar">
    <div class="col">
      <div id="dropzone" class="dropzone" tabindex="0">
        <b>여기에 SRT 또는 DOCX 파일을 드래그&드롭</b><br/>
        <div class="small">또는 아래에서 파일 선택 / 최근 파일 선택</div>
      </div>

      <label>1) SRT 파일(한국어)</label>
      <input id="srtFile" type="file" accept=".srt,text/plain" />

      <label>최근 SRT</label>
      <select id="recentSrt" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col">
      <label>2) Word 번역 파일(.docx)</label>
      <input id="docxFile" type="file" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

      <label>최근 DOCX</label>
      <select id="recentDocx" disabled><option value="">(없음)</option></select>
    </div>

    <div class="col" style="min-width: 440px;">
      <div class="cfg">
        <span class="pill">[オープニングコメント] 제거</span>
        <label style="display:inline-flex; gap:6px; align-items:center; font-weight:700;">
          <input id="dropOpeningLabel" type="checkbox" checked /> ON
        </label>
      </div>

      <div class="controls">
        <button id="runBtn" disabled>변환 실행</button>
        <button id="dlBtn" disabled>결과 SRT 다운로드</button>
      </div>

      <div class="status" id="status">파일을 올려주세요.</div>
      <div class="smallNote">
        ※ 다운로드 파일명: <b>[SRT의 8자리날짜]_jp.srt</b> (예: 20260218_jp.srt)
      </div>
      <div class="smallNote">
        ※ 표의 일본어 편집칸을 클릭해 둔 뒤, 오른쪽 DOCX에서 <b>일본어 줄 클릭</b>하면 자동 삽입됩니다.
        (기존 값 있으면 <b>아래줄로 추가</b>) / 삽입·수정하면 자동 OK
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">결과(왼쪽)</div>
          <div class="small">매칭 상세(일본어 편집 가능, 편집 시 OK로 변경) / 행 클릭 → 오른쪽 DOCX 하이라이트/이동</div>
        </div>
        <div class="small" id="leftStat"></div>
      </div>

      <div class="panelBody">
        <div class="pill">매칭 상세</div>

        <div style="max-height: 1000px; overflow:auto; border:1px solid #eee; border-radius: 12px; margin-top:8px;">
          <table>
            <thead>
              <tr>
                <th class="colIdx">#</th>
                <th class="colTime">시간</th>
                <th class="colKo">원문(한글)</th>
                <th class="colJp">치환(일본어, 편집)</th>
                <th class="colStat">상태</th>
              </tr>
            </thead>
            <tbody id="detailBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="title">DOCX 원문(오른쪽)</div>
          <div class="small">일본어 줄 클릭 → 왼쪽 치환칸에 삽입</div>
        </div>

        <div class="findBox">
          <input id="docFind" type="text" placeholder="오른쪽 내용 검색(하이라이트)" />
          <button id="findBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">찾기</button>
          <button id="clearFindBtn" disabled style="background:#fff;color:#111;border:1px solid #333;">해제</button>
        </div>
      </div>

      <div class="panelBody">
        <div id="docxView" class="docxWrap">(DOCX 파일을 올리면 여기에 내용이 표시됩니다)</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const recent = { srt: [], docx: [] };
  let srtText = "";
  let docxTextRaw = "";

  // 다운로드 파일명 베이스 (SRT 파일명에서 8자리 날짜 우선)
  let srtFileNameBase = "output";

  let lastBlocks = [];
  let lastReport = [];

  // 제목/본문(성경구절) 추출
  let docTitleExtract = { title: "", passage: "" };
  // 오프닝 이전 숫자 원고(1 〜) 추출
  let docManuscriptMap = new Map();

  let docxViewLines = [];
  let lastFocusedTextarea = null;

  const statusEl = $("status");
  const runBtn = $("runBtn");
  const dlBtn = $("dlBtn");
  const detailBody = $("detailBody");
  const leftStat = $("leftStat");

  const docxView = $("docxView");
  const docFind = $("docFind");
  const findBtn = $("findBtn");
  const clearFindBtn = $("clearFindBtn");

  const recentSrtSel = $("recentSrt");
  const recentDocxSel = $("recentDocx");
  const dropzone = $("dropzone");

  // help modal
  const helpBtn = $("helpBtn");
  const helpModal = $("helpModal");
  const helpClose = $("helpClose");

  function openHelp() { helpModal.style.display = "flex"; helpModal.setAttribute("aria-hidden", "false"); }
  function closeHelp() { helpModal.style.display = "none"; helpModal.setAttribute("aria-hidden", "true"); }
  helpBtn.addEventListener("click", openHelp);
  helpClose.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  function setStatus(html) { statusEl.innerHTML = html; }
  function canRun() { return srtText.trim().length > 0 && docxTextRaw.trim().length > 0; }
  function updateRunBtn() { runBtn.disabled = !canRun(); }

  function upsertRecent(list, item) {
    const idx = list.findIndex(x => x.name === item.name);
    if (idx >= 0) list.splice(idx, 1);
    list.unshift(item);
    if (list.length > 8) list.length = 8;
  }
  function refreshRecentSelects() {
    recentSrtSel.innerHTML = `<option value="">(선택)</option>` +
      recent.srt.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentSrtSel.disabled = recent.srt.length === 0;

    recentDocxSel.innerHTML = `<option value="">(선택)</option>` +
      recent.docx.map((x, i) => `<option value="${i}">${x.name}</option>`).join("");
    recentDocxSel.disabled = recent.docx.length === 0;
  }

  function hasHangul(str) { return /[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(str); }
  function hasJapanese(str) { return /[\u3040-\u30ff\u4e00-\u9fff]/.test(str); }

  // 한글 키 정규화 (띄어쓰기/줄바꿈/따옴표 제거)
  function normalizeKo(str) {
    return (str || "")
      .replace(/\uFEFF/g, "")
      .replace(/[“”"]/g, "")
      .replace(/\s+/g, "")
      .replace(/[·…]/g, "")
      .trim();
  }

  // [라벨] : 내용 형태면 내용만
  function cleanKoKey(line) {
    const m = (line || "").match(/^(.{1,30})\s*:\s*(.+)$/);
    if (m) {
      const left = m[1].trim();
      const right = m[2].trim();
      if (left.startsWith("[") && left.endsWith("]")) return right;
      if (left.length <= 8) return right;
    }
    return (line || "").trim();
  }

  function normalizeTimeLine(t) { return (t || "").trim(); }

  function isNumericOnlyBody(body) {
    const s = (body || "").trim();
    return /^\d+$/.test(s);
  }

  function isTitleMarker(body) {
    return (body || "").replace(/\s+/g, "").trim() === "제목";
  }

  function isOpeningMarker(body) {
    const s = (body || "").trim();
    return s.startsWith("[오프닝 멘트]") || s.startsWith("[오프닝멘트]") || s.startsWith("[오프닝") || s.startsWith("오프닝 멘트");
  }

  // SRT 파일명에서 8자리 날짜 우선 추출
  function computeSrtBaseName(filename) {
    const name = (filename || "").replace(/^.*[\\/]/, "");
    const noExt = name.replace(/\.[^.]+$/, "");
    const m = noExt.match(/(\d{8})/);
    if (m && m[1]) return m[1];
    return noExt || "output";
  }

  // SRT 파싱: idx/time/body 그대로 유지
  function parseSrt(text) {
    const blocks = text.replace(/\r/g, "").split(/\n\s*\n/);
    const items = [];
    for (const blk of blocks) {
      const lines = blk.split("\n");
      if (lines.length < 2) continue;

      const idx = (lines[0] || "").trim();
      const time = normalizeTimeLine(lines[1] || "");
      const body = lines.slice(2).join("\n").trim();

      if (!time.includes("-->")) continue;
      items.push({ idx: idx || String(items.length + 1), time, body });
    }
    return items;
  }

  // ===== fuzzy matching helpers =====
  function makeBigrams(s) {
    const x = (s || "").trim();
    const arr = [];
    for (let i = 0; i < x.length - 1; i++) arr.push(x.slice(i, i + 2));
    return arr;
  }
  function diceSim(a, b) {
    if (!a || !b) return 0;
    if (a === b) return 1;

    const A = makeBigrams(a);
    const B = makeBigrams(b);
    if (A.length === 0 || B.length === 0) return 0;

    const map = new Map();
    for (const g of A) map.set(g, (map.get(g) || 0) + 1);

    let inter = 0;
    for (const g of B) {
      const c = map.get(g) || 0;
      if (c > 0) { inter++; map.set(g, c - 1); }
    }
    return (2 * inter) / (A.length + B.length);
  }
  function findBestKoKey(normKo, koKeys, threshold = 0.88) {
    if (!normKo) return { key: "", score: 0 };

    // 부분 포함 우선
    for (const k of koKeys) {
      if (!k) continue;
      if (k.includes(normKo) || normKo.includes(k)) {
        const score = 0.95;
        if (score >= threshold) return { key: k, score };
      }
    }

    // Dice 최고값
    let bestK = "";
    let bestS = 0;
    for (const k of koKeys) {
      const s = diceSim(normKo, k);
      if (s > bestS) { bestS = s; bestK = k; }
    }
    if (bestS >= threshold) return { key: bestK, score: bestS };
    return { key: "", score: bestS };
  }

  // ===== DOCX: title/passage extraction (タイトル / 本　　文) =====
  function extractTitleAndPassage(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim()).filter(Boolean);
    let title = "";
    let passage = "";

    for (const ln of lines) {
      const s = ln.trim();
      if (!s) continue;

      if (!title) {
        const m = s.match(/^タイトル\s*:\s*(.+)$/);
        if (m && m[1]) title = m[1].trim();
      }

      if (!passage) {
        let m = s.match(/^本文\s*:\s*(.+)$/);
        if (!m || !m[1]) m = s.match(/^本[\s　]*文\s*:\s*(.+)$/);
        if (m && m[1]) passage = m[1].trim();
      }

      if (title && passage) break;
    }
    return { title, passage };
  }

  // ===== DOCX: extract manuscript numbered JP lines BEFORE opening marker in DOCX =====
  function extractManuscriptNumberedJP(docRaw) {
    const lines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      if (!ln) continue;

      // DOCX에서 오프닝 멘트 등장하면 그 이전까지만 원고숫자 사용
      if (hasHangul(ln) && isOpeningMarker(ln)) break;

      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (!m) continue;

      const num = Number(m[1]);
      const rest = (m[2] || "").trim();
      if (!(Number.isFinite(num) && num > 0 && rest && hasJapanese(rest))) continue;

      let buf = [rest];
      for (let j = i + 1; j < lines.length; j++) {
        const nx = lines[j].trim();
        if (!nx) break;
        if (hasHangul(nx) && isOpeningMarker(nx)) break;
        const nxNum = nx.match(/^(\d{1,3})\s+(.+)$/);
        if (nxNum) break;
        buf.push(nx);
        i = j;
      }
      map.set(num, buf.join("\n").trim());
    }
    return map;
  }

  // ===== KO->JP dict build =====
  function stripJpLabels(jpLines, dropOpeningLabel) {
    const out = [];
    for (let ln of jpLines) {
      ln = (ln || "").trim();
      if (!ln) continue;
      if (dropOpeningLabel && /^\[オープニングコメント\]\s*:/i.test(ln)) continue;
      out.push(ln);
    }
    return out.join("\n").trim();
  }

  function buildKoToJpMap(docText, dropOpeningLabel) {
    const lines = docText.replace(/\r/g, "").split("\n").map(x => x.trim());
    const map = new Map();

    let currentKo = null;
    let jpBuf = [];

    function flush() {
      if (!currentKo) return;
      const koKey = normalizeKo(cleanKoKey(currentKo));
      const jpText = stripJpLabels(jpBuf, dropOpeningLabel);
      if (koKey && jpText) {
        if (!map.has(koKey)) map.set(koKey, jpText);
      }
      currentKo = null;
      jpBuf = [];
    }

    for (const ln of lines) {
      if (!ln) continue;
      if (hasHangul(ln)) { flush(); currentKo = ln; }
      else { if (currentKo) jpBuf.push(ln); }
    }
    flush();
    return map;
  }

  // remove blank lines (JP)
  function removeBlankLinesAggressive(text) {
    const lines = (text || "").replace(/\r/g, "").split("\n");
    const out = [];
    for (const ln of lines) {
      const t = ln.trim();
      if (!t) continue;
      out.push(ln.trim());
    }
    return out.join("\n").trim();
  }

  // ===== DOCX VIEW PREPROCESS =====
  // 1) "43 こうして..." -> "43" + "こうして..." 분리
  // 2) 일어-일어 사이 빈줄 제거
  // 3) 한글로 넘어가기 직전엔 빈줄 1줄(구분)
  function buildDocxViewLines(docRaw) {
    const rawLines = docRaw.replace(/\r/g, "").split("\n").map(x => x.trimEnd());
    const step1 = [];

    for (const ln0 of rawLines) {
      const ln = (ln0 || "").trim();
      if (!ln) { step1.push(""); continue; }

      const m = ln.match(/^(\d{1,3})\s+(.+)$/);
      if (m) {
        const num = m[1];
        const rest = (m[2] || "").trim();
        if (rest && hasJapanese(rest)) {
          step1.push(num);
          step1.push(rest);
          continue;
        }
      }
      step1.push(ln);
    }

    const out = [];
    for (let i = 0; i < step1.length; i++) {
      const cur = (step1[i] ?? "").trim();
      const prev = (out.length ? out[out.length - 1] : "");
      const next = (i + 1 < step1.length) ? (step1[i + 1] ?? "").trim() : "";

      if (!cur) {
        if (prev && next && hasJapanese(prev) && hasJapanese(next)) continue; // JP-JP 빈줄 제거
        if (out.length && out[out.length - 1] === "") continue; // 연속 빈줄 제거
        out.push("");
        continue;
      }

      if (hasHangul(cur) && prev && prev !== "" && hasJapanese(prev)) {
        if (out[out.length - 1] !== "") out.push("");
      }

      out.push(cur);
    }

    while (out.length && out[out.length - 1] === "") out.pop();
    return out.map(t => ({ text: t, isBlank: t === "" }));
  }

  function renderDocxView(lines) {
    docxViewLines = lines;
    docxView.innerHTML = "";
    if (!lines || !lines.length) {
      docxView.textContent = "(DOCX 내용이 없습니다)";
      return;
    }

    lines.forEach((ln, idx) => {
      if (ln.isBlank) {
        const div = document.createElement("div");
        div.className = "docBlank";
        div.dataset.lineIndex = String(idx);
        docxView.appendChild(div);
        return;
      }
      const span = document.createElement("span");
      span.className = "docLine";
      span.dataset.lineIndex = String(idx);
      span.textContent = ln.text;
      docxView.appendChild(span);
      docxView.appendChild(document.createTextNode("\n"));
    });
  }

  function highlightInDocx(query) {
    const q = (query || "").trim();
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
    if (!q) return false;

    let first = null;
    all.forEach(el => {
      if (first) return;
      if ((el.textContent || "").includes(q)) first = el;
    });

    if (first) {
      first.classList.add("selected");
      first.scrollIntoView({ block: "center" });
      return true;
    }
    return false;
  }

  function makeDocxAnchorFromKo(koRaw) {
    const raw = (koRaw || "").trim();
    if (!raw) return "";
    const lines = raw.split("\n").map(s => s.trim()).filter(Boolean);
    const hangulLines = lines.filter(hasHangul).map(cleanKoKey);
    let bestLine = "";
    for (const ln of hangulLines) if (ln.length > bestLine.length) bestLine = ln;
    if (bestLine.length > 70) bestLine = bestLine.slice(0, 70);
    bestLine = bestLine.replace(/[“”"]/g, "").trim();
    return bestLine;
  }

  // ===== output rebuild (no preview box) =====
  function rebuildOutSrtFromBlocks() {
    const lines = [];
    for (let i = 0; i < lastBlocks.length; i++) {
      const b = lastBlocks[i];
      const r = lastReport[i];
      const edited = (r && typeof r.jpEdited === "string") ? r.jpEdited.trim() : "";
      const body = edited ? edited : b.body;
      lines.push(`${b.idx}\n${b.time}\n${body}`);
    }
    return lines.join("\n\n");
  }

  function refreshOkFailCounts() {
    let ok = 0, fail = 0;
    for (const r of lastReport) {
      if (r.ok) ok++; else fail++;
    }
    leftStat.textContent = `OK ${ok} / FAIL ${fail}`;
    setStatus(`변환 상태: <b>성공 ${ok}</b> / <b>실패 ${fail}</b> (치환칸 입력하면 자동 OK)`);
  }

  function updateRowUIByIndex(i) {
    const tr = detailBody.querySelector(`tr[data-report-index="${i}"]`);
    if (!tr) return;
    const r = lastReport[i];
    if (!r) return;

    if (r.ok) tr.classList.remove("unmatched");
    else tr.classList.add("unmatched");

    const statTd = tr.querySelector("td.colStat");
    if (!statTd) return;

    const sub = r.special ? `<div class="mono" style="font-size:12px;color:#666;">${r.special}</div>` : "";
    statTd.innerHTML = r.ok
      ? `<span class="ok">OK</span>${sub}`
      : `<span class="bad">FAIL</span>${sub}`;
  }

  function renderReport(report) {
    detailBody.innerHTML = "";
    lastReport = report;

    for (let i = 0; i < report.length; i++) {
      const r = report[i];
      const tr = document.createElement("tr");
      tr.classList.add("clickable");
      if (!r.ok) tr.classList.add("unmatched");
      tr.dataset.reportIndex = String(i);

      const jpInitial = r.jp || "";
      r.jpEdited = jpInitial;

      const specialSub = r.special ? `<div class="mono" style="font-size:12px;color:#666;">${r.special}</div>` : "";

      tr.innerHTML = `
        <td class="mono colIdx">${r.idx}</td>
        <td class="mono colTime">${r.time}</td>
        <td class="mono colKo">${r.ko || ""}</td>
        <td class="colJp">
          <textarea class="jpEdit ${r.ok ? "" : "fail"}"
            data-jp-index="${i}" spellcheck="false"
            placeholder="${r.ok ? "필요하면 일본어를 수정하세요" : "여기에 일본어를 직접 입력(FAIL 해결)"}">${jpInitial}</textarea>
        </td>
        <td class="colStat">
          ${r.ok ? `<span class="ok">OK</span>${specialSub}` : `<span class="bad">FAIL</span>${specialSub}`}
        </td>
      `;
      detailBody.appendChild(tr);
    }

    refreshOkFailCounts();
  }

  // textarea focus tracking
  detailBody.addEventListener("focusin", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;
    lastFocusedTextarea = ta;
  });

  // 치환칸 입력 시 OK/FAIL 자동 변경 + 카운트 갱신
  detailBody.addEventListener("input", (e) => {
    const ta = e.target.closest("textarea.jpEdit");
    if (!ta) return;

    const idx = Number(ta.dataset.jpIndex);
    if (!Number.isFinite(idx) || !lastReport[idx]) return;

    // 빈줄 일괄 제거(원하면 여기서 강제 적용)
    // ta.value = removeBlankLinesAggressive(ta.value);

    lastReport[idx].jpEdited = ta.value;

    const hasText = (ta.value || "").trim().length > 0;
    lastReport[idx].ok = hasText;

    if (hasText) ta.classList.remove("fail");
    else ta.classList.add("fail");

    updateRowUIByIndex(idx);
    refreshOkFailCounts();
  });

  // row click -> docx highlight
  detailBody.addEventListener("click", (e) => {
    const tr = e.target.closest("tr");
    if (!tr) return;
    const idx = Number(tr.dataset.reportIndex);
    const row = lastReport[idx];
    if (!row) return;

    const prev = detailBody.querySelector("tr.selectedRow");
    if (prev) prev.classList.remove("selectedRow");
    tr.classList.add("selectedRow");

    const anchor = makeDocxAnchorFromKo(row.ko);
    if (!anchor) return;
    docFind.value = anchor;
    highlightInDocx(anchor);
  });

  // RIGHT CLICK INSERT: doc line click -> textarea append
  function insertToFocusedTextarea(text) {
    if (!lastFocusedTextarea) {
      setStatus(`<span style="color:#c00;font-weight:900;">주의:</span> 먼저 왼쪽 표에서 일본어 수정칸을 한 번 클릭해 주세요.`);
      return;
    }
    const cleaned = removeBlankLinesAggressive(text);
    if (!cleaned) return;

    const cur = lastFocusedTextarea.value || "";
    const nextVal = cur.trim() ? (cur.replace(/\s+$/,"") + "\n" + cleaned) : cleaned;

    lastFocusedTextarea.value = nextVal;

    const idx = Number(lastFocusedTextarea.dataset.jpIndex);
    if (Number.isFinite(idx) && lastReport[idx]) {
      lastReport[idx].jpEdited = nextVal;
      const hasText = nextVal.trim().length > 0;
      lastReport[idx].ok = hasText;
      if (hasText) lastFocusedTextarea.classList.remove("fail");
      else lastFocusedTextarea.classList.add("fail");
      updateRowUIByIndex(idx);
      refreshOkFailCounts();
    }

    lastFocusedTextarea.focus();
    lastFocusedTextarea.selectionStart = lastFocusedTextarea.selectionEnd = lastFocusedTextarea.value.length;
  }

  docxView.addEventListener("click", (e) => {
    const lineEl = e.target.closest(".docLine");
    if (!lineEl) return;
    const text = (lineEl.textContent || "").trim();
    if (!text) return;
    insertToFocusedTextarea(text);
  });

  // 핵심: SRT 타이밍/블록 그대로, 블록별 문장만 매칭 + FUZZY
  function convertAll_SrtTimingFixed(srtItems, ko2jp, koKeys) {
    const out = [];
    const report = [];
    let srtOpeningSeen = false;

    for (let i = 0; i < srtItems.length; i++) {
      const item = srtItems[i];
      const koBodyRaw = (item.body || "").trim();

      if (isOpeningMarker(koBodyRaw)) srtOpeningSeen = true;

      // (A) 제목
      if (isTitleMarker(koBodyRaw)) {
        const title = (docTitleExtract.title || "").trim();
        const passage = (docTitleExtract.passage || "").trim();
        const jp = [title, passage].filter(Boolean).join("\n").trim();

        out.push({ idx: item.idx, time: item.time, body: jp || koBodyRaw });
        report.push({
          idx: item.idx, time: item.time, ko: koBodyRaw,
          jp: jp || "", ok: !!jp,
          special: "TITLE"
        });
        continue;
      }

      // (B) 숫자만: 오프닝 전까지만 원고 숫자 대체
      if (!srtOpeningSeen && isNumericOnlyBody(koBodyRaw)) {
        const num = Number(koBodyRaw);
        const jp = docManuscriptMap.get(num) || "";

        out.push({ idx: item.idx, time: item.time, body: jp || koBodyRaw });
        report.push({
          idx: item.idx, time: item.time, ko: koBodyRaw,
          jp: jp || "", ok: !!jp,
          special: "NUM"
        });
        continue;
      }

      // (C) 일반: 이 블록 한글로만 매칭
      const normKey1 = normalizeKo(koBodyRaw);
      let jp = normKey1 ? (ko2jp.get(normKey1) || "") : "";
      let special = "";

      // 라벨형 보정
      let normKey2 = "";
      if (!jp) {
        normKey2 = normalizeKo(cleanKoKey(koBodyRaw));
        if (normKey2) jp = ko2jp.get(normKey2) || "";
      }

      // FUZZY (정확매칭 실패 시)
      if (!jp) {
        const base = normKey2 || normKey1;
        const best = findBestKoKey(base, koKeys, 0.88); // 더 느슨하게 하려면 0.85
        if (best.key) {
          jp = ko2jp.get(best.key) || "";
          special = `FUZZY ${best.score.toFixed(2)}`;
        }
      }

      out.push({ idx: item.idx, time: item.time, body: jp || koBodyRaw });
      report.push({
        idx: item.idx, time: item.time, ko: koBodyRaw,
        jp: jp || "", ok: !!jp,
        special: jp ? (special || "") : "FAIL"
      });
    }

    return { out, report };
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  async function loadSrtFromFile(file) {
    const text = await file.text();
    srtText = text;
    srtFileNameBase = computeSrtBaseName(file.name);

    upsertRecent(recent.srt, { name: file.name, text });
    refreshRecentSelects();

    setStatus(`SRT 로드됨: <b>${file.name}</b> → 저장명: <b>${srtFileNameBase}_jp.srt</b>`);
    updateRunBtn();
  }

  async function loadDocxFromFile(file) {
    const arrBuf = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer: arrBuf });
    docxTextRaw = (result.value || "").trim();

    upsertRecent(recent.docx, { name: file.name, text: docxTextRaw });
    refreshRecentSelects();

    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `DOCX 로드됨: <b>${file.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  }

  $("srtFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadSrtFromFile(f);
  });

  $("docxFile").addEventListener("change", async (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    await loadDocxFromFile(f);
  });

  recentSrtSel.addEventListener("change", () => {
    const v = recentSrtSel.value;
    if (v === "") return;
    const item = recent.srt[Number(v)];
    if (!item) return;

    srtText = item.text;
    srtFileNameBase = computeSrtBaseName(item.name);

    setStatus(`최근 SRT 선택: <b>${item.name}</b> → 저장명: <b>${srtFileNameBase}_jp.srt</b>`);
    updateRunBtn();
  });

  recentDocxSel.addEventListener("change", () => {
    const v = recentDocxSel.value;
    if (v === "") return;
    const item = recent.docx[Number(v)];
    if (!item) return;

    docxTextRaw = item.text;

    docTitleExtract = extractTitleAndPassage(docxTextRaw);
    docManuscriptMap = extractManuscriptNumberedJP(docxTextRaw);

    const lines = buildDocxViewLines(docxTextRaw);
    renderDocxView(lines);

    findBtn.disabled = docxTextRaw.length === 0;
    clearFindBtn.disabled = docxTextRaw.length === 0;

    setStatus(
      `최근 DOCX 선택: <b>${item.name}</b> (タイトル:${docTitleExtract.title ? "OK" : "NO"} / 本文:${docTitleExtract.passage ? "OK" : "NO"} / 원고숫자:${docManuscriptMap.size}개)`
    );
    updateRunBtn();
  });

  function handleDropFiles(fileList) {
    const files = Array.from(fileList || []);
    if (!files.length) return;
    for (const f of files) {
      const name = (f.name || "").toLowerCase();
      if (name.endsWith(".srt")) loadSrtFromFile(f);
      else if (name.endsWith(".docx")) loadDocxFromFile(f);
    }
  }

  dropzone.addEventListener("dragover", (e) => { e.preventDefault(); dropzone.classList.add("dragover"); });
  dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
  dropzone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
    handleDropFiles(e.dataTransfer.files);
  });

  dropzone.addEventListener("click", () => {
    const picker = document.createElement("input");
    picker.type = "file";
    picker.multiple = true;
    picker.accept = ".srt,.docx";
    picker.onchange = () => handleDropFiles(picker.files);
    picker.click();
  });

  $("findBtn").addEventListener("click", () => highlightInDocx(docFind.value));
  $("clearFindBtn").addEventListener("click", () => {
    docFind.value = "";
    const all = docxView.querySelectorAll(".docLine");
    all.forEach(el => el.classList.remove("selected"));
  });

  runBtn.addEventListener("click", () => {
    try {
      const srtItems = parseSrt(srtText);
      const dropOpeningLabel = $("dropOpeningLabel").checked;
      const ko2jp = buildKoToJpMap(docxTextRaw, dropOpeningLabel);
      const koKeys = Array.from(ko2jp.keys());

      setStatus(`처리 중... (SRT <b>${srtItems.length}</b> / KO→JP 사전 <b>${ko2jp.size}</b> / 원고숫자 <b>${docManuscriptMap.size}</b>)`);

      const { out, report } = convertAll_SrtTimingFixed(srtItems, ko2jp, koKeys);

      lastBlocks = out;
      renderReport(report);
      dlBtn.disabled = false;

    } catch (err) {
      console.error(err);
      setStatus(`<span style="color:#c00;font-weight:900;">오류:</span> ${(err?.message || String(err))}`);
    }
  });

  dlBtn.addEventListener("click", () => {
    const content = rebuildOutSrtFromBlocks();
    if (!content.trim()) return;
    downloadText(`${srtFileNameBase}_jp.srt`, content);
  });

})();
</script>
</body>
</html>
