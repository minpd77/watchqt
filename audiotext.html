<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ìŒì„± ë°›ì•„ì“°ê¸°</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    margin-top: 80px;
  }

  /* ë§ˆì´í¬ + ì•ˆë‚´ë¬¸êµ¬ë¥¼ í•œ ì¤„ë¡œ */
  #micRow{
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 18px;
  }

  #micButton {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: none;
    font-size: 40px;
    color: white;
    cursor: pointer;
    background-color: green;
    flex: 0 0 auto;
  }

  /* ë§ˆì´í¬ ì˜¤ë¥¸ìª½, ë¹¨ê°„ ê¸€ì”¨, í¬ê¸° 250% */
  #recordHint {
    display: none;
    color: red;
    font-size: 250%;
    font-weight: 800;
    line-height: 1.2;
    text-align: left;
    white-space: pre-line; /* ì¤„ë°”ê¿ˆ ê·¸ëŒ€ë¡œ */
  }

  #copyButton {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
  }

  #output {
    margin-top: 30px;
    width: 80%;
    height: 200px;
    font-size: 18px;
  }

  /* ì „ì²´í™”ë©´ ë³µì‚¬ ì•Œë¦¼ */
  #copyAlert {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.8);
    color: white;
    display: none;
    justify-content: center;
    align-items: center;
    font-size: 40px;
    z-index: 9999;
  }

  /* ì˜µì…˜ ë°” */
  #optionsBar {
    margin-top: 16px;
    display: inline-flex;
    gap: 14px;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    color: #444;
    font-size: 14px;
  }

  label { user-select: none; }
</style>
</head>
<body>

<div id="micRow">
  <button id="micButton">ğŸ¤</button>
  <div id="recordHint">ì¸ì‹ì¤‘...
ìŒì„± ë°›ì•„ì“°ê¸° ì¤‘.... ë§ˆì´í¬ë¥¼ ëˆ„ë¥´ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.</div>
</div>

<br>
<button id="copyButton">ë³µì‚¬í•˜ê¸°</button>

<div id="optionsBar">
  <label>
    <input type="checkbox" id="copyFinalOnly" checked />
    ë³µì‚¬ ì‹œ í™•ì •(final)ë§Œ
  </label>

  <label>
    <input type="checkbox" id="autoPunct" checked />
    ìë™ êµ¬ë‘ì (. ? !)
  </label>

  <label title="ì˜ˆ: 'ì‰¼í‘œ', 'ë§ˆì¹¨í‘œ'ë¥¼ ë§í•˜ë©´ ê¸°í˜¸ë¡œ ë°”ê¿‰ë‹ˆë‹¤">
    <input type="checkbox" id="spokenPunct" checked />
    ë§í•œ êµ¬ë‘ì  ë³€í™˜(ì‰¼í‘œ/ë§ˆì¹¨í‘œ/ë¬¼ìŒí‘œ/ëŠë‚Œí‘œ)
  </label>
</div>

<br>
<textarea id="output" placeholder="ìŒì„±ì´ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ë©ë‹ˆë‹¤..."></textarea>

<div id="copyAlert">ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!</div>

<script>
const micButton = document.getElementById("micButton");
const copyButton = document.getElementById("copyButton");
const output = document.getElementById("output");
const copyAlert = document.getElementById("copyAlert");
const recordHintEl = document.getElementById("recordHint");

const copyFinalOnlyEl = document.getElementById("copyFinalOnly");
const autoPunctEl = document.getElementById("autoPunct");
const spokenPunctEl = document.getElementById("spokenPunct");

let recognizing = false;
let shouldAutoRestart = false;

// í…ìŠ¤íŠ¸ ë²„í¼
let finalText = "";     // í™•ì •(ìµœì¢…) ëˆ„ì 
let interimText = "";   // ë§í•˜ëŠ” ì¤‘ê°„(ì„ì‹œ)

// Web Speech API
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
  alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
}

const recognition = new SpeechRecognition();
recognition.lang = "ko-KR";
recognition.continuous = true;
recognition.interimResults = true;
recognition.maxAlternatives = 1;

/* ---------------------
   UI í—¬í¼
--------------------- */
function setMicUI(on){
  micButton.style.backgroundColor = on ? "red" : "green";
  recordHintEl.style.display = on ? "block" : "none";
}

function renderOutput(){
  output.value = finalText + (interimText ? interimText : "");
  output.scrollTop = output.scrollHeight;
}

/* ---------------------
   êµ¬ë‘ì  ì²˜ë¦¬ ë¡œì§
--------------------- */
function normalizeSpaces(s){
  return String(s ?? "").replace(/\s+/g, " ").trim();
}

function convertSpokenPunctuation(s){
  // ë§ë¡œ í•œ êµ¬ë‘ì ì„ ê¸°í˜¸ë¡œ ì¹˜í™˜ (ì˜µì…˜ ONì¼ ë•Œë§Œ)
  // ì˜ˆ: "ì‰¼í‘œ" -> ",", "ë§ˆì¹¨í‘œ" -> ".", "ë¬¼ìŒí‘œ" -> "?", "ëŠë‚Œí‘œ" -> "!"
  // í”í•œ ë°œí™” ë³€í˜•ë„ ì¼ë¶€ í¬í•¨
  return s
    .replace(/\bì‰¼í‘œ\b/g, ",")
    .replace(/\bì½¤ë§ˆ\b/g, ",")
    .replace(/\bë§ˆì¹¨í‘œ\b/g, ".")
    .replace(/\bí”¼ë¦¬ì–´ë“œ\b/g, ".")
    .replace(/\bë¬¼ìŒí‘œ\b/g, "?")
    .replace(/\bí€˜ìŠ¤ì²œë§ˆí¬\b/g, "?")
    .replace(/\bëŠë‚Œí‘œ\b/g, "!")
    .replace(/\bì—‘ìŠ¤í´ëŸ¬ë©”ì´ì…˜\b/g, "!");
}

function hasTerminalPunct(s){
  return /[.?!â€¦]+$/.test(s.trim());
}

function guessTerminalPunctKorean(sentence){
  // ë§¤ìš° ë³´ìˆ˜ì ìœ¼ë¡œ ë¬¸ì¥ ë ì–´ë¯¸ë¡œ . / ? / ! ì¶”ì •
  const s = sentence.trim();
  if (!s) return "";

  // ì´ë¯¸ ì¢…ê²°ë¶€í˜¸ë©´ ìœ ì§€
  if (hasTerminalPunct(s)) return "";

  // ê´„í˜¸/ë”°ì˜´í‘œ ë“± ë‹«í˜ ì²˜ë¦¬: ëì— ) ] } " ' ë“±ì´ ìˆì–´ë„ íŒë‹¨ ê°€ëŠ¥í•˜ë„ë¡ ë¶„ë¦¬
  // ì˜ˆ) "ë§ë‚˜ìš”)" -> core="ë§ë‚˜ìš”", tail=")"
  const m = s.match(/^(.*?)([)\]\}"'â€™â€]+)?$/);
  const core = (m && m[1]) ? m[1].trim() : s;
  const tail = (m && m[2]) ? m[2] : "";

  const c = core;

  // ì§ˆë¬¸í˜• ì–´ë¯¸ íŒ¨í„´
  if (/(ê¹Œ|ë‚˜ìš”|ë‹ˆ|ëƒ|ë‚˜ìš”|ìŠµë‹ˆê¹Œ|ì¸ê°€ìš”|ì¸ê°€|ì£ \?|ì§€ìš”\?|ê°€ìš”)\s*$/.test(c)) return "?" + tail;

  // ëŠë‚Œ/ê°•ì¡°(ì•„ì£¼ ë³´ìˆ˜ì ): ëì´ "!" ë§íˆ¬ë¡œ ìì£¼ ëë‚˜ëŠ” ì¼€ì´ìŠ¤ë§Œ
  if (/(ë‹¤!|ì•¼!|ì!|ì•„!|ì–´!|í•´!|ë´!|ì¢‹ì•„!|ëŒ€ë°•!|ì§„ì§œ!|ì™€!|í—!)\s*$/.test(c)) return "!" + tail;

  // ê¸°ë³¸ì€ ë§ˆì¹¨í‘œ
  return "." + tail;
}

function applyPunctuationToFinal(text){
  let t = normalizeSpaces(text);

  if (spokenPunctEl.checked) {
    t = convertSpokenPunctuation(t);
    t = t.replace(/\s*([,?.!])\s*/g, "$1 "); // ê¸°í˜¸ ì£¼ë³€ ê³µë°± ì •ë¦¬
    t = t.replace(/\s+/g, " ").trim();
  }

  if (autoPunctEl.checked) {
    // ë¬¸ì¥ ëì— . ? ! ì—†ìœ¼ë©´ ì¶”ì •í•´ì„œ ë¶€ì°©
    // ë‹¨, ë§ˆì§€ë§‰ì— ì½¤ë§ˆë¡œ ëë‚¬ìœ¼ë©´ ë§ˆì¹¨í‘œ ê°•ì œí•˜ì§€ ì•ŠìŒ
    if (!/[.?!â€¦]+$/.test(t) && !/,$/.test(t)) {
      const add = guessTerminalPunctKorean(t);
      if (add) t = t + add; // guessTerminalPunctKoreanê°€ tail í¬í•¨í•´ì„œ ë°˜í™˜í•˜ë„ë¡ ë§Œë“¤ì—ˆìœ¼ë‹ˆ ì—¬ê¸°ì„  ë§ë¶™ì„
      // ìœ„ì—ì„œ addì— tailê¹Œì§€ ë“¤ì–´ê°€ë©´ ì¤‘ë³µì´ ë  ìˆ˜ ìˆì–´, í˜„ì¬ êµ¬í˜„ì€ addê°€ "?)+tail" í˜•íƒœë¼ì„œ t+addê°€ ë§ì§€ ì•ŠìŒ
      // -> ì•ˆì „í•˜ê²Œ ë‹¤ì‹œ êµ¬í˜„: addëŠ” ìˆœìˆ˜ ë¶€í˜¸ë§Œ ë°˜í™˜í•˜ë„ë¡ ì²˜ë¦¬
    }
  }

  // ìœ„ ì½”ë©˜íŠ¸ ë°˜ì˜: ì•ˆì „í•˜ê²Œ ë‹¤ì‹œ ì¢…ê²°ë¶€í˜¸ ë¶€ì°©
  if (autoPunctEl.checked) {
    if (!/[.?!â€¦]+$/.test(t) && !/,$/.test(t)) {
      // tail í¬í•¨ ë²„ì „ ëŒ€ì‹ , ì—¬ê¸°ì„œëŠ” ë¶€í˜¸ë§Œ ë¶™ì´ê¸° (ë‹«í˜ë¬¸ì ë’¤ì—ëŠ” ë¶€í˜¸ ëª» ë¶™ì´ë¯€ë¡œ ì˜ˆì™¸ ì²˜ë¦¬)
      // ë‹«í˜ë¬¸ì ê¼¬ë¦¬ ë¶„ë¦¬
      const mm = t.match(/^(.*?)([)\]\}"'â€™â€]+)?$/);
      const core = (mm && mm[1]) ? mm[1].trim() : t.trim();
      const tail = (mm && mm[2]) ? mm[2] : "";

      let punct = ".";
      if (/(ê¹Œ|ë‚˜ìš”|ë‹ˆ|ëƒ|ìŠµë‹ˆê¹Œ|ì¸ê°€ìš”|ì¸ê°€|ê°€ìš”)\s*$/.test(core)) punct = "?";
      else if (/(ì•¼|ì|ì•„|ì–´|í•´|ë´|ì¢‹ì•„|ëŒ€ë°•|ì§„ì§œ|ì™€|í—)\s*$/.test(core)) punct = "!";

      t = core + punct + tail;
    }
  }

  // ë§ˆì§€ë§‰ ê³µë°± ì •ë¦¬
  t = t.replace(/\s+$/g, "");
  return t;
}

/* ---------------------
   ì‹œì‘/ì¤‘ì§€
--------------------- */
function startRecognition(){
  try {
    recognition.start();
    recognizing = true;
    shouldAutoRestart = true;
    setMicUI(true);
  } catch (e) {
    console.warn("startRecognition error:", e);
  }
}

function stopRecognition(){
  shouldAutoRestart = false;
  try { recognition.stop(); } catch (e) { console.warn("stopRecognition error:", e); }

  recognizing = false;
  interimText = "";
  setMicUI(false);
  renderOutput();
}

micButton.addEventListener("click", () => {
  if (!recognizing) startRecognition();
  else stopRecognition();
});

/* ---------------------
   ìŒì„± ê²°ê³¼ ì²˜ë¦¬
--------------------- */
recognition.onresult = (event) => {
  interimText = "";

  for (let i = event.resultIndex; i < event.results.length; i++) {
    const res = event.results[i];
    const raw = res[0].transcript;

    if (res.isFinal) {
      const processed = applyPunctuationToFinal(raw);
      finalText += processed + "\n";
    } else {
      // interimì€ ë„ˆë¬´ ê°€ê³µí•˜ë©´ ê¹œë¹¡ì„/ì˜¤íŒì´ ìƒê²¨ì„œ ì›ë¬¸ ê·¸ëŒ€ë¡œ í‘œì‹œ
      interimText += raw;
    }
  }

  renderOutput();
};

/* ---------------------
   ëŠê¹€ ìµœì†Œí™”: ì¢…ë£Œë˜ë©´ ìë™ ì¬ì‹œì‘
--------------------- */
recognition.onend = () => {
  if (shouldAutoRestart) {
    setTimeout(() => startRecognition(), 60);
  } else {
    setMicUI(false);
  }
};

/* ---------------------
   ì˜¤ë¥˜ ì²˜ë¦¬
--------------------- */
recognition.onerror = (event) => {
  console.error("ìŒì„± ì¸ì‹ ì˜¤ë¥˜:", event.error);

  if (event.error === "no-speech" || event.error === "aborted") return;

  shouldAutoRestart = false;
  recognizing = false;
  setMicUI(false);
};

/* ---------------------
   ë³µì‚¬ ë²„íŠ¼
--------------------- */
copyButton.addEventListener("click", async () => {
  const textOnly = copyFinalOnlyEl.checked
    ? finalText
    : (finalText + (interimText ? interimText : ""));

  try {
    await navigator.clipboard.writeText(textOnly);

    copyAlert.style.display = "flex";
    setTimeout(() => { copyAlert.style.display = "none"; }, 1200);

  } catch (err) {
    alert("ë³µì‚¬ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
  }
});

/* ---------------------
   í˜ì´ì§€ ë– ë‚  ë•Œ ì •ë¦¬
--------------------- */
window.addEventListener("beforeunload", () => {
  try { recognition.abort(); } catch(e){}
});
</script>

</body>
</html>
