<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ìŒì„± ë°›ì•„ì“°ê¸°</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; margin-top: 80px; }
  #micRow{ display: inline-flex; align-items: center; justify-content: center; gap: 18px; }
  #micButton {
    width: 100px; height: 100px; border-radius: 50%;
    border: none; font-size: 40px; color: white; cursor: pointer;
    background-color: green; flex: 0 0 auto;
  }
  #recordHint {
    display: none; color: red; font-size: 250%; font-weight: 800;
    line-height: 1.2; text-align: left; white-space: pre-line;
  }
  #buttonsRow {
    margin-top: 20px;
    display: inline-flex; gap: 12px;
    align-items: center; justify-content: center; flex-wrap: wrap;
  }
  #copyButton, #clearButton { padding: 10px 20px; font-size: 16px; cursor: pointer; }
  #output { margin-top: 30px; width: 80%; height: 200px; font-size: 18px; }
  #copyAlert {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0,0,0,0.8); color: white; display: none;
    justify-content: center; align-items: center; font-size: 40px; z-index: 9999;
  }
  #optionsBar {
    margin-top: 16px;
    display: inline-flex; gap: 14px;
    align-items: center; justify-content: center; flex-wrap: wrap;
    color: #444; font-size: 14px;
  }
  label { user-select: none; }
</style>
</head>
<body>

<div id="micRow">
  <button id="micButton">ğŸ¤</button>
  <div id="recordHint">ì¸ì‹ì¤‘...
ìŒì„± ë°›ì•„ì“°ê¸° ì¤‘.... ë§ˆì´í¬ë¥¼ ëˆ„ë¥´ë©´ ì¢…ë£Œ ë©ë‹ˆë‹¤.</div>
</div>

<br>

<div id="buttonsRow">
  <button id="copyButton">ë³µì‚¬í•˜ê¸°</button>
  <button id="clearButton">ë‚´ìš© ì§€ìš°ê¸°</button>
</div>

<div id="optionsBar">
  <label>
    <input type="checkbox" id="copyFinalOnly" checked />
    ë³µì‚¬ ì‹œ í™•ì •(final)ë§Œ
  </label>

  <label>
    <input type="checkbox" id="autoPunct" checked />
    ìë™ êµ¬ë‘ì (. ? !)
  </label>

  <label title="ì˜ˆ: 'ì‰¼í‘œ', 'ë§ˆì¹¨í‘œ'ë¥¼ ë§í•˜ë©´ ê¸°í˜¸ë¡œ ë°”ê¿‰ë‹ˆë‹¤">
    <input type="checkbox" id="spokenPunct" checked />
    ë§í•œ êµ¬ë‘ì  ë³€í™˜(ì‰¼í‘œ/ë§ˆì¹¨í‘œ/ë¬¼ìŒí‘œ/ëŠë‚Œí‘œ)
  </label>
</div>

<br>
<textarea id="output" placeholder="ìŒì„±ì´ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ë©ë‹ˆë‹¤..."></textarea>

<div id="copyAlert">ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!</div>

<script>
const micButton = document.getElementById("micButton");
const copyButton = document.getElementById("copyButton");
const clearButton = document.getElementById("clearButton");
const output = document.getElementById("output");
const copyAlert = document.getElementById("copyAlert");
const recordHintEl = document.getElementById("recordHint");

const copyFinalOnlyEl = document.getElementById("copyFinalOnly");
const autoPunctEl = document.getElementById("autoPunct");
const spokenPunctEl = document.getElementById("spokenPunct");

let recognizing = false;
let shouldAutoRestart = false;

// í…ìŠ¤íŠ¸ ë²„í¼
let finalText = "";
let interimText = "";

// âœ… ì¹¨ë¬µ 1ì´ˆë©´ ë¬¸ì¥ í™•ì • (ìš”ì²­)
const MAX_SILENCE_MS = 1000;
const ENDING_COMMIT_DELAY_MS = 350;

// íƒ€ì´ë¨¸
let lastUpdateAt = 0;
let silenceTimer = null;
let pendingCommitTimer = null;

// ì¤‘ë³µ ë°©ì§€
const RECENT_FINAL_TTL_MS = 8000;
const recentFinalMap = new Map();
let lastCommittedLineKey = "";

/* ---------------------
   âœ… â€œì‹¤ì œ ëª©ì†Œë¦¬â€ ê²Œì´íŠ¸ (í•µì‹¬)
   - ì¹¨ë¬µ/ì¡ìŒ/í”¼ë“œë°±ìœ¼ë¡œ ìƒê¸°ëŠ” í—›ë¬¸ì¥ì„ ë§‰ìŒ
--------------------- */
let audioCtx = null;
let analyser = null;
let micStream = null;
let rmsTimer = null;
let lastVoiceAt = 0;
let audioGateReady = false;

// ëª©ì†Œë¦¬ë¡œ íŒë‹¨í•  ìµœì†Œ RMS (í™˜ê²½ë§ˆë‹¤ ë‹¤ë¦„)
// ë„ˆë¬´ ë¯¼ê°í•˜ë©´ ì˜¬ë¦¬ê³ (0.03~0.05), ë„ˆë¬´ ë‘”í•˜ë©´ ë‚´ë¦¬ê³ (0.01~0.02)
const VOICE_RMS_THRESHOLD = 0.02;

// final ì±„íƒ: ë§ˆì§€ë§‰ìœ¼ë¡œ ëª©ì†Œë¦¬ ê°ì§€ëœ ì§€ N ms ì´ë‚´ì—¬ì•¼ í•¨
const ACCEPT_WITHIN_MS = 1200;

async function startAudioGate(){
  try{
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);

    const buf = new Float32Array(analyser.fftSize);

    rmsTimer = setInterval(() => {
      if (!analyser) return;
      analyser.getFloatTimeDomainData(buf);

      let sum = 0;
      for (let i=0; i<buf.length; i++){
        const v = buf[i];
        sum += v*v;
      }
      const rms = Math.sqrt(sum / buf.length);

      if (rms >= VOICE_RMS_THRESHOLD) {
        lastVoiceAt = Date.now();
      }
    }, 60);

    audioGateReady = true;
  }catch(e){
    // ê¶Œí•œ ê±°ë¶€/ë¸Œë¼ìš°ì € ì œí•œ ì‹œ: ê²Œì´íŠ¸ ì—†ì´ ë™ì‘ (í•„í„°ë¡œë§Œ ë°©ì–´)
    audioGateReady = false;
    console.warn("Audio gate disabled:", e);
  }
}

function stopAudioGate(){
  audioGateReady = false;
  if (rmsTimer) { clearInterval(rmsTimer); rmsTimer = null; }
  if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
  analyser = null;
  if (micStream) {
    try { micStream.getTracks().forEach(t => t.stop()); } catch(e){}
    micStream = null;
  }
  lastVoiceAt = 0;
}

function hasRecentVoice(){
  if (!audioGateReady) return true; // ê²Œì´íŠ¸ê°€ ì—†ìœ¼ë©´ í†µê³¼(í•„í„°ë¡œë§Œ ë°©ì–´)
  return (Date.now() - lastVoiceAt) <= ACCEPT_WITHIN_MS;
}

/* ---------------------
   UI
--------------------- */
function setMicUI(on){
  micButton.style.backgroundColor = on ? "red" : "green";
  recordHintEl.style.display = on ? "block" : "none";
}

function renderOutput(){
  output.value = finalText + (interimText ? interimText : "");
  output.scrollTop = output.scrollHeight;
}

/* ---------------------
   êµ¬ë‘ì 
--------------------- */
function normalizeSpaces(s){
  return String(s ?? "").replace(/\s+/g, " ").trim();
}

function convertSpokenPunctuation(s){
  return s
    .replace(/\bì‰¼í‘œ\b/g, ",")
    .replace(/\bì½¤ë§ˆ\b/g, ",")
    .replace(/\bë§ˆì¹¨í‘œ\b/g, ".")
    .replace(/\bí”¼ë¦¬ì–´ë“œ\b/g, ".")
    .replace(/\bë¬¼ìŒí‘œ\b/g, "?")
    .replace(/\bí€˜ìŠ¤ì²œë§ˆí¬\b/g, "?")
    .replace(/\bëŠë‚Œí‘œ\b/g, "!")
    .replace(/\bì—‘ìŠ¤í´ëŸ¬ë©”ì´ì…˜\b/g, "!");
}

function applyPunctuationToFinal(text){
  let t = normalizeSpaces(text);

  if (spokenPunctEl.checked) {
    t = convertSpokenPunctuation(t);
    t = t.replace(/\s*([,?.!â€¦])\s*/g, "$1 ");
    t = t.replace(/\s+/g, " ").trim();
  }

  if (autoPunctEl.checked) {
    if (!/[.?!â€¦]+$/.test(t) && !/,$/.test(t)) {
      const mm = t.match(/^(.*?)([)\]\}"'â€™â€]+)?$/);
      const core = (mm && mm[1]) ? mm[1].trim() : t.trim();
      const tail = (mm && mm[2]) ? mm[2] : "";

      let punct = ".";
      if (/(ê¹Œ|ë‚˜ìš”|ë‹ˆ|ëƒ|ìŠµë‹ˆê¹Œ|ì¸ê°€ìš”|ì¸ê°€|ê°€ìš”)\s*$/.test(core)) punct = "?";
      else if (/(ì•¼|ì|ì•„|ì–´|í•´|ë´|ì¢‹ì•„|ëŒ€ë°•|ì§„ì§œ|ì™€|í—)\s*$/.test(core)) punct = "!";

      t = core + punct + tail;
    }
  }

  return t.replace(/\s+$/g, "");
}

/* ---------------------
   âœ… â€œí—›ë¬¸ì¥â€ í•„í„° (UI ë¬¸êµ¬/ë°˜ë³µë¬¸êµ¬ ì°¨ë‹¨)
   - í•„ìš” ì—†ìœ¼ë©´ blacklistWords ë°°ì—´ë§Œ ë¹„ì›Œë„ ë¨
--------------------- */
const blacklistWords = [
  "ì¸ì‹ì¤‘",
  "ì¸ì‹ ì¤‘",
  "ìŒì„± ë°›ì•„ì“°ê¸°",
  "ë§ˆì´í¬ë¥¼ ëˆ„ë¥´ë©´ ì¢…ë£Œ",
  "ë§ˆì´í¬ë¡œ ëˆ„ë¥´ë©´ ì¢…ë£Œ",
  "ì¢…ë£Œ ë©ë‹ˆë‹¤"
];

function isBlacklisted(s){
  const t = normalizeSpaces(s);
  if (!t) return true; // ë¹ˆ ë¬¸ì¥ì€ ë²„ë¦¼
  return blacklistWords.some(w => t.includes(w));
}

/* ---------------------
   ì¤‘ë³µ ë°©ì§€
--------------------- */
function makeDedupeKey(s){
  let t = String(s ?? "");
  t = t.replace(/\s+/g, " ").trim();
  t = t.replace(/[â€œâ€"']/g, "");
  t = t.replace(/\s*([,?.!â€¦])\s*/g, "$1");
  t = t.replace(/[.?!â€¦]+$/g, ".");
  return t;
}

function cleanupRecentFinals(){
  const now = Date.now();
  for (const [k, ts] of recentFinalMap.entries()){
    if (now - ts > RECENT_FINAL_TTL_MS) recentFinalMap.delete(k);
  }
}

function isDuplicateFinal(line){
  cleanupRecentFinals();
  const key = makeDedupeKey(line);

  if (key && lastCommittedLineKey && key === lastCommittedLineKey) return true;
  if (recentFinalMap.has(key)) return true;

  if (key) recentFinalMap.set(key, Date.now());
  return false;
}

/* ---------------------
   ë¬¸ì¥ ë ì–´ë¯¸ ê°ì§€
--------------------- */
function seemsSentenceEnding(s){
  const t = normalizeSpaces(s);
  if (!t) return false;
  if (/[.?!â€¦]+$/.test(t)) return true;

  const mm = t.match(/^(.*?)([)\]\}"'â€™â€]+)?$/);
  const core = (mm && mm[1]) ? mm[1].trim() : t.trim();

  return /(ì…ë‹ˆë‹¤|ë©ë‹ˆë‹¤|í•©ë‹ˆë‹¤|í–ˆìŠµë‹ˆë‹¤|í•˜ì„¸ìš”|í•´ìš”|í–ˆì–´ìš”|ëì–´ìš”|ë˜ë‚˜ìš”|ë˜ì£ |ë˜ë„¤ìš”|ì¸ê°€ìš”|ì¼ê¹Œìš”|ë ê¹Œìš”|ê¹Œìš”|ë‚˜ìš”|ì£ |ì§€ìš”|ë„¤ìš”|êµ°ìš”|ì–´ìš”|ì•„ìš”|ì˜ˆìš”|ì´ì—ìš”|ë‹¤)\s*$/.test(core);
}

/* ---------------------
   ê°•ì œ í™•ì •
--------------------- */
function commitInterim(reason){
  if (!interimText) return;

  if (pendingCommitTimer) {
    clearTimeout(pendingCommitTimer);
    pendingCommitTimer = null;
  }

  // âœ… ì¹¨ë¬µ/ì¡ìŒ êµ¬ê°„ì´ë©´ í™•ì • ìì²´ë¥¼ í•˜ì§€ ì•ŠìŒ (í—›ë¬¸ì¥ ë°©ì§€)
  if (!hasRecentVoice()) {
    interimText = "";
    renderOutput();
    return;
  }

  const processed = applyPunctuationToFinal(interimText);

  // âœ… blacklistë©´ ë²„ë¦¼
  if (isBlacklisted(processed)) {
    interimText = "";
    renderOutput();
    return;
  }

  lastCommittedLineKey = makeDedupeKey(processed);
  recentFinalMap.set(lastCommittedLineKey, Date.now());

  finalText += processed + "\n";
  interimText = "";
  renderOutput();
}

/* ---------------------
   íƒ€ì´ë¨¸ (ì¹¨ë¬µ 1ì´ˆ í™•ì •)
--------------------- */
function startWatchers(){
  stopWatchers();
  lastUpdateAt = Date.now();

  silenceTimer = setInterval(() => {
    if (!recognizing) return;

    const idle = Date.now() - lastUpdateAt;

    // âœ… 1ì´ˆ ì¹¨ë¬µì´ë©´ í™•ì •
    if (idle >= MAX_SILENCE_MS && interimText) {
      commitInterim("max-silence");
      return;
    }

    if (interimText && seemsSentenceEnding(interimText)) {
      if (!pendingCommitTimer) {
        pendingCommitTimer = setTimeout(() => {
          if (interimText && seemsSentenceEnding(interimText)) {
            commitInterim("ending");
          }
          pendingCommitTimer = null;
        }, ENDING_COMMIT_DELAY_MS);
      }
    } else {
      if (pendingCommitTimer) {
        clearTimeout(pendingCommitTimer);
        pendingCommitTimer = null;
      }
    }
  }, 120);
}

function stopWatchers(){
  if (silenceTimer) { clearInterval(silenceTimer); silenceTimer = null; }
  if (pendingCommitTimer) { clearTimeout(pendingCommitTimer); pendingCommitTimer = null; }
}

/* ---------------------
   Web Speech API
--------------------- */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
  alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
}

const recognition = new SpeechRecognition();
recognition.lang = "ko-KR";
recognition.continuous = true;
recognition.interimResults = true;
recognition.maxAlternatives = 1;

/* ---------------------
   ì‹œì‘/ì¤‘ì§€
--------------------- */
async function startRecognition(){
  try {
    // âœ… ì˜¤ë””ì˜¤ ê²Œì´íŠ¸ ì‹œì‘(ê¶Œí•œ ìš”ì²­)
    await startAudioGate();

    recognition.start();
    recognizing = true;
    shouldAutoRestart = true;
    setMicUI(true);
    startWatchers();
  } catch (e) {
    console.warn("startRecognition error:", e);
  }
}

function stopRecognition(){
  shouldAutoRestart = false;
  try { recognition.stop(); } catch (e) { console.warn("stopRecognition error:", e); }

  recognizing = false;
  interimText = "";
  setMicUI(false);
  stopWatchers();
  stopAudioGate();
  renderOutput();
}

micButton.addEventListener("click", () => {
  if (!recognizing) startRecognition();
  else stopRecognition();
});

/* ---------------------
   âœ… ê²°ê³¼ ì²˜ë¦¬
   - interim ëˆ„ì  ê¸ˆì§€
   - â€œìµœê·¼ ì‹¤ì œ ëª©ì†Œë¦¬â€ê°€ ìˆì–´ì•¼ finalì„ ì±„íƒ
   - blacklist/ì¤‘ë³µ ë°©ì§€
--------------------- */
recognition.onresult = (event) => {
  lastUpdateAt = Date.now();

  let newInterim = "";

  for (let i = event.resultIndex; i < event.results.length; i++) {
    const res = event.results[i];
    const raw = res[0].transcript;

    if (res.isFinal) {
      // âœ… ì‹¤ì œ ëª©ì†Œë¦¬ ì—†ìœ¼ë©´ final ë²„ë¦¼ (ì¹¨ë¬µ/ì¡ìŒ í—›ë¬¸ì¥ ë°©ì§€)
      if (!hasRecentVoice()) continue;

      const processed = applyPunctuationToFinal(raw);

      // âœ… UI/í—›ë¬¸ì¥ í•„í„°
      if (isBlacklisted(processed)) continue;

      // âœ… final ì¤‘ë³µ ë°©ì§€
      if (!isDuplicateFinal(processed)) {
        finalText += processed + "\n";
      }

      newInterim = "";
    } else {
      // âœ… ë§ˆì§€ë§‰ interimë§Œ ìœ ì§€
      newInterim = raw;
    }
  }

  // interimë„ â€œí—›ë¬¸ì¥â€ì´ë©´ í‘œì‹œ ìì²´ë¥¼ ì•ˆ í•¨
  if (newInterim && (isBlacklisted(newInterim) || !hasRecentVoice())) {
    newInterim = "";
  }

  const prev = interimText;
  interimText = newInterim;

  if (interimText !== prev) renderOutput();
};

/* ---------------------
   ìë™ ì¬ì‹œì‘
--------------------- */
recognition.onend = () => {
  if (shouldAutoRestart) {
    setTimeout(() => {
      try { recognition.start(); } catch(e){}
    }, 80);
  } else {
    setMicUI(false);
  }
};

/* ---------------------
   ì˜¤ë¥˜ ì²˜ë¦¬
--------------------- */
recognition.onerror = (event) => {
  console.error("ìŒì„± ì¸ì‹ ì˜¤ë¥˜:", event.error);
  if (event.error === "no-speech" || event.error === "aborted") return;

  shouldAutoRestart = false;
  recognizing = false;
  setMicUI(false);
  stopWatchers();
  stopAudioGate();
};

/* ---------------------
   ë³µì‚¬
--------------------- */
copyButton.addEventListener("click", async () => {
  const textOnly = copyFinalOnlyEl.checked
    ? finalText
    : (finalText + (interimText ? interimText : ""));

  try {
    await navigator.clipboard.writeText(textOnly);
    copyAlert.style.display = "flex";
    setTimeout(() => { copyAlert.style.display = "none"; }, 1200);
  } catch (err) {
    alert("ë³µì‚¬ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
  }
});

/* ---------------------
   ë‚´ìš© ì§€ìš°ê¸°
--------------------- */
clearButton.addEventListener("click", () => {
  interimText = "";
  finalText = "";
  output.value = "";
  output.scrollTop = 0;

  recentFinalMap.clear();
  lastCommittedLineKey = "";
  lastUpdateAt = Date.now();
});

/* ---------------------
   ì •ë¦¬
--------------------- */
window.addEventListener("beforeunload", () => {
  try { recognition.abort(); } catch(e){}
  stopAudioGate();
});
</script>

</body>
</html>
